<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>预编译与变量提升</title>
      <link href="/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译与变量提升"><a href="#预编译与变量提升" class="headerlink" title="预编译与变量提升"></a><center>预编译与变量提升</center></h2><h4 id="1-JavaScript执行三部曲"><a href="#1-JavaScript执行三部曲" class="headerlink" title="1. JavaScript执行三部曲"></a>1. JavaScript执行三部曲</h4><ul><li>语法分析</li><li>预编译</li><li>解析执行</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h4><ul><li>JavaScript预编译发生在代码片段执行前，分为<code>全局预编译（GO: Global Object）</code>、<code>函数预编译（AO: Activation Object）</code>，全局预编译发生在<code>script</code>标签引入执行时（全局作用域），函数预编译发生在函数执行前一刻（函数作用域）。预编译会创建当前环境的执行上下文。</li><li>预编译发生在<code>变量声明</code>和<code>函数声明</code>，<code>匿名函数</code>和<code>函数表达式</code>不进行预编译</li></ul><h4 id="3-Imply-global（暗示全局变量）"><a href="#3-Imply-global（暗示全局变量）" class="headerlink" title="3. Imply global（暗示全局变量）"></a>3. Imply global（暗示全局变量）</h4><p>  任何变量未经声明就赋值，此变量就变为<code>全局对象（window，globalThis）</code>所有</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123; a = <span class="number">2</span> &#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="4-全局预编译"><a href="#4-全局预编译" class="headerlink" title="4. 全局预编译"></a>4. 全局预编译</h4><ul><li>创建<code>GO（Global Object）</code></li><li>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 变量声明）</li></ul><h4 id="5-全局预编译过程"><a href="#5-全局预编译过程" class="headerlink" title="5. 全局预编译过程"></a>5. 全局预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = z = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">y = <span class="title function_">add</span>(x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">z = <span class="title function_">add</span>(x)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>GO</code></p></li><li><p>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Go</span>&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GO</span>&#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">add</span>: <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">1</span> &#125; =&gt; <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-函数预编译"><a href="#6-函数预编译" class="headerlink" title="6. 函数预编译"></a>6. 函数预编译</h4><ul><li>创建<code>AO（Activation Object）</code></li><li>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>将实参值与形参统一</li><li>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 实参 &gt; 变量声明）</li></ul><h4 id="7-函数预编译过程"><a href="#7-函数预编译过程" class="headerlink" title="7. 函数预编译过程"></a>7. 函数预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">fn</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>AO</code></p></li><li><p>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将实参值与形参统一</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">d</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-变量提升（Hoisting）"><a href="#8-变量提升（Hoisting）" class="headerlink" title="8. 变量提升（Hoisting）"></a>8. 变量提升（<code>Hoisting</code>）</h4><p>  在预编译过程中，<code>变量声明</code>，<code>函数声明</code>会被移到调用前，从而产生<code>变量提升</code></p><ul><li><p><code>函数声明</code>整体提升，无论函数调用和声明的位置是前是后，总会被函数声明移到调用前，函数名与形参或变量名同名时：<code>函数声明</code> &gt; <code>实参</code> &gt; <code>变量声明</code></p></li><li><p><code>匿名函数</code>和<code>函数表达式</code>不会提升</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// undefined: 变量提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()) <span class="comment">// not defined: 函数表达式不会提升</span></span><br></pre></td></tr></table></figure></li><li><p><code>变量声明</code>提升，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p></li><li><p><code>var</code>：<code>创建</code>和<code>初始化</code>都被提升</p></li><li><p><code>function</code>：整体提升，<code>创建</code>、<code>初始化</code>、<code>赋值</code>都提升</p></li><li><p><code>let</code>、<code>const</code>：<code>创建</code>提升（即变量已存在，但只有等到变量声明语句执行后才能使用）</p></li><li><p>ES6 <code>import</code>具有提升效果，导入模块会提升到整个模块的头部，首先执行（<code>import</code>静态编译，<code>import()</code>，<code>require()</code>动态加载）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-暂时性死区（Temporal-dead-zone，简称TDZ）"><a href="#9-暂时性死区（Temporal-dead-zone，简称TDZ）" class="headerlink" title="9. 暂时性死区（Temporal dead zone，简称TDZ）"></a>9. 暂时性死区（Temporal dead zone，简称TDZ）</h4><p>  <code>暂时性死区</code>本质是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明语句执行后，才可以获取和使用该变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 死区陷阱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> x <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> z <span class="comment">// Reference Error</span></span><br><span class="line"><span class="keyword">let</span> z</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Surrogate Pair</title>
      <link href="/blog//Surrogate-Pair/"/>
      <url>/blog//Surrogate-Pair/</url>
      
        <content type="html"><![CDATA[<h2 id="Surrogate-Pair"><a href="#Surrogate-Pair" class="headerlink" title="Surrogate Pair"></a><center>Surrogate Pair</center></h2><p>  什么是<code>Surrogate Pair</code>呢？在我了解到它的时候，我只是在Google搜索”<code>如何在JavaScript中获取字符串的最后一位</code>“，于是我得到了下面几种方式，先让我们看看这几种方式</p><h4 id="获取字符串的最后一位的几种方式"><a href="#获取字符串的最后一位的几种方式" class="headerlink" title="获取字符串的最后一位的几种方式"></a>获取字符串的最后一位的几种方式</h4><ul><li><p>substring、substr</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>charAt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>split</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li><li><p>Array.from()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li><li><p>Spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...str].<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li></ul><h4 id="几种方式处理字符串"><a href="#几种方式处理字符串" class="headerlink" title="几种方式处理字符串"></a>几种方式处理字符串</h4><p>  以上几种方式处理字符串正常情况下（如英文字符串）都没有什么问题，让我们来看看执行结果<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;example&#x27;</span></span><br><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">[...str].<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><br>  所有方式都能正确获取字符串的最后一位，但当我们我们字符串中出现<code>Surrogate Pair</code>时（比如emoji），让我们来看看会发生什么<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;example💩&#x27;</span></span><br><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>() <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>() <span class="comment">// &#x27;💩&#x27;</span></span><br><span class="line">[...str].<span class="title function_">pop</span>() <span class="comment">// &#x27;💩&#x27;</span></span><br></pre></td></tr></table></figure><br>  这个结果让是否让你感到费解？接下来让我们了解一下原因吧</p><h4 id="Surrogate-Pair-1"><a href="#Surrogate-Pair-1" class="headerlink" title="Surrogate Pair"></a>Surrogate Pair</h4><ul><li><p>什么是Surrogate Pair</p><p>在Unicode字符集中，有一些字符的码点需要超过16位才能表示。因此，Unicode定义了一种机制，用于将这些字符分成两个16位编码单元。这些编码单元被称为代理项（Surrogate）。一个代理项由两个编码单元组成：高代理项和低代理项。高代理项的编码单元在范围0xD800到0xDBFF之间，而低代理项的编码单元在范围0xDC00到0xDFFF之间</p><p>例如，表情符号😀（U+1F600）是由两个编码单元组成的代理对表示的。高代理项为0xD83D，低代理项为0xDE00。这两个编码单元组成的代理对表示的是一个单个的Unicode字符</p></li><li><p>JavaScript中的Surrogate Pair</p><p>JavaScript使用UTF-16编码，当JavaScript遇到代理对时，它将其解释为两个单独的字符，而不是一个字符，这意味着，如果您正在处理包含代理对的字符串，您需要考虑到这些特殊字符，以确保正确处理字符串中的每个字符</p><p>在处理包含代理对的字符串时，需要注意字符串的长度和索引。由于代理对是由两个16位编码单元组成的，所以当代理对出现在字符串中时，该字符串的长度将增加2而不是1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>此外，在字符串中使用索引访问代理对时需要注意。因为代理对的第一个编码单元在字符串中的索引位置必须是偶数，而第二个编码单元在字符串中的索引位置必须是奇数</p><p>因此，在使用以上几种方式处理<code>Surrogate Pair</code>时，一些方法不能正确进行处理</p></li></ul><h4 id="如何正确处理Surrogate-Pair？"><a href="#如何正确处理Surrogate-Pair？" class="headerlink" title="如何正确处理Surrogate Pair？"></a>如何正确处理<code>Surrogate Pair</code>？</h4><p>  在上面的几种方式中，我们也看到了如何正确处理<code>Surrogate Pair</code></p><ul><li><p>Array.from()</p><p>使用Array.from()能正确的将所有字符串按照你想要的方式处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀hello💩&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str) <span class="comment">// [&#x27;😀&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;💩&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Spread<br>同样使用Spread(扩展运算符)也能进行处理</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀hello💩&#x27;</span></span><br><span class="line">[...str] <span class="comment">// [&#x27;😀&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;💩&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  <code>Surrogate Pair</code>是Unicode字符集中的一些字符，由于其码点超过了16位，因此被拆分为两个16位编码单元。在JavaScript中，由于字符串是UTF-16编码，因此代理对被解释为两个单独的字符。在处理包含代理对的字符串时，需要注意字符串的长度和索引</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
          <category> JavaScript </category>
          
          <category> Unicode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Type &#39;string&#39; is not assignable to type in TypeScript</title>
      <link href="/blog//Type-string-is-not-assignable-to-type-in-TypeScript/"/>
      <url>/blog//Type-string-is-not-assignable-to-type-in-TypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="Type-‘string’-is-not-assignable-to-type-in-Typescript"><a href="#Type-‘string’-is-not-assignable-to-type-in-Typescript" class="headerlink" title="Type ‘string’ is not assignable to type in Typescript"></a><center>Type ‘string’ is not assignable to type in Typescript</center></h2><h4 id="Type-‘string’-is-not-assignable-to-type-in-Typescript-1"><a href="#Type-‘string’-is-not-assignable-to-type-in-Typescript-1" class="headerlink" title="Type ‘string’ is not assignable to type in Typescript"></a>Type ‘string’ is not assignable to type in Typescript</h4><p>  当<code>Typescript</code>出现<code>&quot;Type &#39;string&#39; is not assignable to type&quot;</code>错误时，一般情况是我们将<code>string</code>类型分配给了看起来是字符串类型，其实并不是完整的字符串类型。如<code>literal type(字面量)</code>或者<code>enum(枚举)</code><br>  <br /><br>  解决这个问题其实比较简单，使用常量(const)定义或者类型断言</p><p>  如:<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// yellow: string</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></p><p>  在上例中，变量<code>yellow</code>类型为<code>string</code>,而<code>current</code>类型为<code>PrimaryColor</code>。当我们将<code>string</code>分配给<code>PrimaryColor</code>时就会出现此错误，这是因为，虽然<code>yellow</code>变量的值为<code>PrimaryColor</code>其中之一，但是它是<code>string</code>类型，对<code>PrimaryColor</code>来说太过广泛</p><p>  换句话来说，<code>PrimaryColor</code>只存在三个值<code>&#39;red&#39;</code>、<code>&#39;yellow&#39;</code>、<code>&#39;green&#39;</code>，而string类型可以为任意字符串</p><p>  解决办法：</p><ul><li><p>类型断言(type assertion)</p><p>如上例，我们可以使用类型断言将<code>yellow</code>断言为<code>PrimaryColor</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// yellow: PrimaryColor</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="title class_">PrimaryColor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li><li><p>const断言(const assertion)</p><p>使用const assertion将变量<code>yellow</code>断言为字符串字面量<code>&#39;yellow&#39;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yellow: &#x27;yellow&#x27;</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li><li><p>使用const定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yellow: &#x27;yellow&#x27;</span></span><br><span class="line"><span class="keyword">const</span> yellow = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li></ul><p>  一些其他情况</p><ul><li><p>接下来看看另外一个例子</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Letter</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Letter</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">letter</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">letter</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;Letter&#x27;.</span></span><br><span class="line">arr.<span class="title function_">push</span>(obj.<span class="property">letter</span>)</span><br></pre></td></tr></table></figure><p>因为数组<code>arr</code>类型为<code>Letter[]</code>,而<code>obj.letter</code>类型为<code>string</code>,因此发生错误。</p><p>解决办法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Letter</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Letter</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">letter</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">letter</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type assertion</span></span><br><span class="line">arr.<span class="title function_">push</span>(obj.<span class="property">letter</span> <span class="keyword">as</span> <span class="title class_">Letter</span>)</span><br></pre></td></tr></table></figure><p>如果可以，最好将<code>obj.letter</code>在定义时直接定义为<code>Letter</code>类型</p></li><li><p>还有一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: string[]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string[]&#x27; is not assignable to type &#x27;PrimaryColor[]&#x27;.</span></span><br><span class="line"><span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure><p>原因是<code>arr2</code>类型为<code>string[]</code>，不能将其赋值给<code>PrimaryColor[]</code>，可以使用<code>const assertion</code>解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: readonly [&quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure><p>但是<code>const assertion</code>会将数组转化为只读元组类型，如果你后续想要修改数组中的类型将会发生错误，所以这种方法不适合数组需要修改的情况，可以使用<code>type assertion</code>解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: PrimaryColor[]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>] <span class="keyword">as</span> <span class="title class_">PrimaryColor</span>[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Type-string-is-not-assignable-to-type-Enum-in-Typescript"><a href="#Type-string-is-not-assignable-to-type-Enum-in-Typescript" class="headerlink" title="Type string is not assignable to type Enum in Typescript"></a>Type string is not assignable to type Enum in Typescript</h4><p>  另一种常见情况出现在枚举<code>Enum</code><br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;&quot;yellow&quot;&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color</span>: <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;yellow&#x27;</span></span><br></pre></td></tr></table></figure><br>  解决办法<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color1</span>: <span class="title class_">PrimaryColor</span> = <span class="title class_">PrimaryColor</span>.<span class="property">yellow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color2</span>: <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="title class_">PrimaryColor</span></span><br></pre></td></tr></table></figure></p><h4 id="Type-‘X’-is-not-assignable-to-type-‘Y’-in-Typescript"><a href="#Type-‘X’-is-not-assignable-to-type-‘Y’-in-Typescript" class="headerlink" title="Type ‘X’ is not assignable to type ‘Y’ in Typescript"></a>Type ‘X’ is not assignable to type ‘Y’ in Typescript</h4><p>  这种情况出现赋值时左边的变量与右侧的值具有不兼容的类型，解决办法可以通过<code>type assertion(类型断言)</code>或<code>type guard(类型守卫)</code>在赋值之前比较两个值是否具有兼容性</p><p>  如下例：<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name: string</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;lemox&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">name = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>  变量<code>name</code>初始化时被typescript推断为<code>string</code>类型，当我们将<code>number</code>类型分配给<code>name</code>时就会发生错误。解决办法是确保两个值具有兼容性或者使用类型断言</p><p>  使用联合类型定义变量<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name: string | number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&#x27;lemox&#x27;</span></span><br><span class="line"></span><br><span class="line">name = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>  有时你可能知道两个值具有兼容性，但是typescript不知道，这时你可以使用<code>type assertion(类型断言)</code></p><p>  还有<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = person.<span class="property">name</span></span><br></pre></td></tr></table></figure><br>  由于<code>person.name</code>为可选属性，即存在两种类型<code>string | undefined</code>，因此类型不兼容，可以使用类型断言或类型守卫解决</p><ul><li><p>类型断言</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = person.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span></span><br></pre></td></tr></table></figure><p>可以使用类型断言明确的告诉<code>typescript</code>，当前上下文<code>person.name</code>为<code>string</code></p></li><li><p>类型守卫<br>更好的办法是使用类型守卫</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="keyword">typeof</span> person.<span class="property">name</span> === <span class="string">&#x27;string&#x27;</span> ? person.<span class="property">name</span> : <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样可以确保我们总是给<code>name</code>分配了一个字符串</p></li><li><p>还有一种常见错误</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;number | undefined&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">first</span>: <span class="built_in">number</span> = result</span><br></pre></td></tr></table></figure><p>因为<code>Array.pop()</code>方法的返回值可能为<code>undefined</code>，所以我们不能直接将其分配给<code>number</code>类型，可以使用以上提到的方式解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num1</span>: <span class="built_in">number</span> = result <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num2</span>: <span class="built_in">number</span> | <span class="literal">undefined</span> = result</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型守卫</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num3</span>: <span class="built_in">number</span> = result ?? <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  要解决<code>Type &#39;X&#39; is not assignable to type &#39;Y&#39;</code>问题，主要是需要确保两边值类型的兼容性，如果两个值兼容性不匹配，则会发生错误</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript中的逆变与协变</title>
      <link href="/blog//Typescript%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/"/>
      <url>/blog//Typescript%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Typescript中的逆变与协变"><a href="#Typescript中的逆变与协变" class="headerlink" title="Typescript中的逆变与协变"></a><center>Typescript中的逆变与协变</center></h2><p>  TypeScript 是一门静态类型语言，具有丰富的类型系统特性，其中逆变和协变是两个重要的概念。它们在 TypeScript 中用于描述函数类型、泛型和类继承等场景中的类型转换关系</p><h4 id="什么是逆变和协变"><a href="#什么是逆变和协变" class="headerlink" title="什么是逆变和协变"></a>什么是逆变和协变</h4><p>  在 TypeScript 中，逆变和协变是两个类型转换的方向。逆变用于从更具体的类型转换为更一般的类型，而协变则用于从更一般的类型转换为更具体的类型</p><p>  换句话说，逆变和协变都是用来描述类型之间的包含关系。逆变意味着一个更具体的类型可以替代一个更一般的类型，而协变意味着一个更一般的类型可以替代一个更具体的类型</p><p>  例如，我们有两个类型 A 和 B，如果 A 是 B 的子类型，那么 A 就是更具体的类型，B 就是更一般的类型。逆变和协变分别描述了从 A 到 B 和从 B 到 A 的类型转换关系</p><h4 id="TypeScript中的逆变"><a href="#TypeScript中的逆变" class="headerlink" title="TypeScript中的逆变"></a>TypeScript中的逆变</h4><p>  在 TypeScript 中，逆变通常发生在函数参数的类型转换中。当函数参数的类型需要比函数签名中声明的类型更具体时，就需要使用逆变</p><p>  例如，我们有一个函数 f，它接收一个类型为 B 的参数，并返回一个类型为 A 的结果。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要接收一个类型为 A 的参数，那么我们需要使用逆变。我们可以将 f 函数的参数类型从 B 转换为 A 的超类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">b: B</span>): A &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: b.<span class="property">name</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="function">(<span class="params">a: A</span>) =&gt;</span> A = f <span class="comment">// 使用逆变，将 B 转换为 A 的超类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数 f 接收一个类型为 B 的参数，并返回一个类型为 A 的结果。我们将这个函数赋值给变量 g，并且需要将 B 类型的参数转换为 A 类型，以满足 g 变量的类型要求</p><h4 id="TypeScript中的协变"><a href="#TypeScript中的协变" class="headerlink" title="TypeScript中的协变"></a>TypeScript中的协变</h4><p>  协变通常发生在函数返回值的类型转换中。当函数返回值的类型需要比函数签名中声明的类型更具体时，就需要使用协变</p><p>  例如，我们有一个函数 f，它返回一个类型为 A 的结果，但实际上它返回的是一个类型为 B 的实例，其中 B 是 A 的子类型。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要返回一个类型为 B 的结果，那么我们需要使用协变。我们可以将 f 函数的返回值类型从 A 转换为 B 的子类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): A &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="function">() =&gt;</span> B = f <span class="comment">// 使用协变，将 A 转换为 B 的子类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数 f 返回一个类型为 A 的结果，实际上它返回的是一个类型为 B 的实例。我们将这个函数赋值给变量 g，并且需要将返回值类型从 A 转换为 B 的子类型，以满足 g 变量的类型要求</p><h4 id="TypeScript中的泛型逆变和协变"><a href="#TypeScript中的泛型逆变和协变" class="headerlink" title="TypeScript中的泛型逆变和协变"></a>TypeScript中的泛型逆变和协变</h4><p>  在 TypeScript 中，逆变和协变也可以应用于泛型类型参数。当一个泛型类型参数需要比其声明的类型更具体时，就需要使用逆变；当一个泛型类型参数需要比其声明的类型更一般时，就需要使用协变</p><p>  例如，我们有一个泛型函数 f，它接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，那么我们需要使用逆变。我们可以将泛型类型参数 T 的类型从 <code>Array&lt;B&gt;</code> 转换为 <code>Array&lt;A&gt;</code> 的超类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f&lt;T <span class="keyword">extends</span> B&gt;(<span class="attr">arr</span>: <span class="title class_">Array</span>&lt;T&gt;): <span class="title class_">Array</span>&lt;A&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">name</span>: item.<span class="property">name</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: &lt;T <span class="keyword">extends</span> A&gt;<span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;A&gt; = f <span class="comment">// 使用逆变，将 Array&lt;B&gt; 转换为 Array&lt;A&gt; 的超类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。泛型函数 f 接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组。我们将这个函数赋值给变量 g，并且需要将泛型类型参数 T 的类型从 <code>Array&lt;B&gt;</code> 转换为 <code>Array&lt;A&gt;</code> 的超类型，以满足变量 g 的类型要求</p><p>  另外，需要注意的是，在 TypeScript 中，函数参数和返回值是可以同时具有逆变和协变的</p><p>  例如，我们有一个函数类型 Func，它接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;B&gt;</code> 的数组。如果我们要将这个函数类型赋值给一个变量 f，并且这个变量需要接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组，那么我们需要同时使用逆变和协变</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;A&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;B&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>: <span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;B&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;A&gt; = (<span class="attr">arr</span>: <span class="title class_">Array</span>&lt;B&gt;): <span class="title class_">Array</span>&lt;A&gt; =&gt;</span><br><span class="line">  arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">name</span>: item.<span class="property">name</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="title class_">Func</span> = f <span class="comment">// 同时使用逆变和协变，将参数类型从 Array&lt;B&gt; 转换为 Array&lt;A&gt;，将返回值类型从 Array&lt;A&gt; 转换为 Array&lt;B&gt;</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数类型 Func 接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;B&gt;</code> 的数组。我们将函数 f 赋值给变量 g，并且需要同时使用逆变和协变，以满足变量 g 的类型要求</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  在 TypeScript 中，逆变和协变是非常有用的类型系统特性。它们可以帮助我们更好地理解和设计函数和类型。逆变和协变的区别在于，逆变是指一个类型可以被替换为其超类型，而协变是指一个类型可以被替换为其子类型。在 TypeScript 中，逆变和协变可以应用于函数参数类型、函数返回值类型和泛型类型参数</p><p>  使用逆变和协变可以帮助我们编写更灵活、更通用的代码，同时也可以帮助我们更好地理解和设计接口和类型。在使用逆变和协变时，我们需要注意类型安全性和代码的可读性，以避免出现潜在的错误和困惑</p><p>  希望这篇博客能够帮助你更好地理解 TypeScript 中的逆变和协变，并在实际开发中应用它们</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy</title>
      <link href="/blog//Proxy/"/>
      <url>/blog//Proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><center>Proxy</center></h2><h4 id="1-Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义"><a href="#1-Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义" class="headerlink" title="1. Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义"></a>1. <code>Proxy</code>对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><ul><li><p>target</p><p>要使用<code>Proxy</code>包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</p></li><li><p>handler</p><p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code>的行为</p><p>如果<code>handler</code>没有设置任何拦截行为，那就等同于直接通向原对象</p></li></ul><h4 id="2-要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object-proxy属性，从而可以在对象上调用）"><a href="#2-要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object-proxy属性，从而可以在对象上调用）" class="headerlink" title="2. 要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object.proxy属性，从而可以在对象上调用）"></a>2. 要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例进行操作，而不是针对目标对象进行操作（可以将<code>Proxy</code>对象设置到对象<code>object.proxy</code>属性，从而可以在对象上调用）</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">time</span>) <span class="comment">// &#x27;proxy&#x27;</span></span><br></pre></td></tr></table></figure><p>  <code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p><h4 id="3-Proxy-revocable-：创建一个可撤销的Proxy对象"><a href="#3-Proxy-revocable-：创建一个可撤销的Proxy对象" class="headerlink" title="3. Proxy.revocable()：创建一个可撤销的Proxy对象"></a>3. <code>Proxy.revocable()</code>：创建一个可撤销的<code>Proxy</code>对象</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler)</span><br><span class="line"></span><br><span class="line">proxy <span class="comment">// 对象：代理实例</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">// 函数：取消代理，执行revoke()后再访问就会报错</span></span><br></pre></td></tr></table></figure><h4 id="4-this问题"><a href="#4-this问题" class="headerlink" title="4. this问题"></a>4. <code>this</code>问题</h4><p>  在<code>Proxy</code>代理的情况下，目标对象内部的<code>this</code>关键字会指向<code>Proxy</code>代理，而拦截函数<code>this</code>指向<code>handler</code>对象</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hander</span></span><br><span class="line">    target[prop] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// target</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// proxy</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;lemon&#x27;</span></span><br></pre></td></tr></table></figure><p>  此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以<code>Proxy</code>也无法代理这些原生对象的属性</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>()</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><h4 id="5-handler对象的方法（目前标准的是13种）"><a href="#5-handler对象的方法（目前标准的是13种）" class="headerlink" title="5. handler对象的方法（目前标准的是13种）"></a>5. <code>handler</code>对象的方法（目前标准的是13种）</h4><ul><li><code>get(target, prop, receiver)</code>：属性读取操作的捕捉器</li><li><code>set(target, prop, value, receiver)</code>：属性设置操作的捕捉器，返回一个布尔值</li><li><code>has(target, prop)</code>：<code>in</code>操作符的捕捉器，返回一个布尔值</li><li><code>deleteProperty(target, property)</code>：<code>delete</code>操作符的捕捉器，返回一个布尔值</li><li><code>ownKeys(target)</code>：<code>Object.getOwnPropertyNames</code>方法和 <code>Object.getOwnPropertySymbols</code>方法的捕捉器，返回一个数组</li><li><code>getOwnPropertyDescriptor(target, prop)</code>：<code>Object.getOwnPropertyDescriptor</code>方法的捕捉器，返回属性的描述对象</li><li><code>defineProperty(target, property, descriptor)</code>：<code>Object.defineProperty</code>方法的捕捉器，返回一个布尔值</li><li><code>preventExtensions(target)</code>：<code>Object.preventExtensions</code>方法的捕捉器，返回一个布尔值</li><li><code>getPrototypeOf(target)</code>：<code>Object.getPrototypeOf</code>方法的捕捉器，返回一个布尔值</li><li><code>setPrototypeOf(target, prototype)</code>：<code>Object.setPrototypeOf</code>方法的捕捉器，返回一个布尔值</li><li><code>isExtensible(target)</code>：<code>Object.isExtensible</code>方法的捕捉器，返回一个布尔值</li><li><code>apply(target, thisArg, argumentsList)</code>：函数调用操作的捕捉器</li><li><code>construct(target, argumentsList, newTarget)</code>：<code>new</code>操作符的捕捉器，返回一个对象</li></ul><h4 id="6-实例"><a href="#6-实例" class="headerlink" title="6. 实例"></a>6. 实例</h4><ul><li><p><code>get(target, prop, receiver)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">receiver</span>: <span class="string">&#x27;Proxy或者继承Proxy的对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象的属性不可配置<code>configurable: false</code>且不可写<code>writable: false</code>，则<code>Proxy</code>不能修改该属性，通过<code>Proxy</code>访问该属性会报错</li><li>如果目标属性没有配置访问方法，即get方法为<code>undefined</code>，则返回值必须为<code>undefined</code></li></ul></li><li><p><code>set(target, prop, value, receiver)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;属性值&#x27;</span>, <span class="attr">receiver</span>: <span class="string">&#x27;Proxy实例本身&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象的属性不可写<code>writable: false</code>，则<code>set</code>方法无效</li><li>返回<code>Boolean</code>值，<code>true</code>设置成功，<code>false</code>设置失败（严格模式<code>false</code>会报错）</li><li>如果目标属性没有配置储存方法，即<code>set</code>方法为<code>undefined</code>，则不能设置值</li></ul></li><li><p><code>apply(target, thisArg, argumentsList)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">thisArg</span>: <span class="string">&#x27;目标对象的上下文对象（this）&#x27;</span>, <span class="attr">argumentsList</span>: <span class="string">&#x27;参数数组&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> twice = &#123;</span><br><span class="line">  apply (target, thisArg, argumentsList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice)</span><br><span class="line"><span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>target</code>必须是可以被调用的，即必须是一个函数对象</li></ul></li><li><p><code>has(target, prop)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象不可扩展，使用<code>has</code>拦截就会报错</li><li>如果目标对象的某一属性本身不可被配置，使用<code>has</code>拦截就会报错</li></ul></li><li><p><code>construct(target, argumentsList, newTarget)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象（函数）&#x27;</span>, <span class="attr">argumentsList</span>: <span class="string">&#x27;参数数组&#x27;</span>, <span class="attr">newTarget</span>: <span class="string">&#x27;new 命令作用的构造函数&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：返回值必须是一个对象，否则会报错，由于<code>construct()</code>拦截构造函数，所以目标对象必须是函数</p></li><li><p><code>deleteProperty(target, property)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>deleteProperty</code>必须返回一个 <code>Boolean</code>类型的值，表示了该属性是否被成功删除</li><li>如果目标对象属性不可配置<code>configurable: false</code>，不能被删除，就会报错</li></ul></li><li><p><code>defineProperty(target, property, descriptor)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">descriptor</span>: <span class="string">&#x27;待定义或修改的属性的描述符&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>defineProperty</code>方法必须以一个 <code>Boolean</code>返回，表示定义该属性的操作成功与否（严格模式返回<code>false</code>会报错）</li><li>如果目标对象不可扩展（<code>non-extensible</code>），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错</li><li>如果目标对象属性不可写<code>writable</code>或不可配置<code>configurable</code>，则<code>defineProperty()</code>方法不能改变这两个设置</li></ul></li><li><p><code>getOwnPropertyDescriptor(target, prop)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>getOwnPropertyDescriptor</code>必须返回一个<code>object</code>或<code>undefined</code></li></ul></li><li><p><code>getPrototypeOf(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>getPrototypeOf()</code>必须返回对象或者<code>null</code>，否则会报错</li><li>如果目标对象不可扩展（<code>non-extensible</code>），<code>getPrototypeOf()</code>方法必须返回目标对象的原型对象</li></ul></li><li><p><code>isExtensible(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>isExtensible()</code>必须返回布尔值，否则返回值会被自动转为布尔值，且返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则会保持</li></ul></li><li><p><code>ownKeys(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>自动过滤，不会返回（1. 不存在的属性 2. Symbol属性 3. 不可遍历<code>enumerable</code>属性）</li><li><code>ownkeys()</code>方法返回的数组成员，只能是字符串或<code>Symbol</code>值，其他类型或者根本不是数组就会报错</li><li>如果目标对象包含不可配置的属性，则该属性必须被<code>ownkeys()</code>返回，否则会报错</li><li>如果目标对象不可扩展（<code>non-extensible</code>），<code>ownkeys()</code>必须返回原对象的所有属性，且不能包含多余的属性，否则会报错</li></ul></li><li><p><code>preventExtensions(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>preventExtensions()</code>有一个限制，只有当目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>只能返回<code>true</code>，否则会报错</li><li><code>preventExtensions()</code>返回一个布尔值</li></ul></li><li><p><code>setPrototypeOf(target, prototype)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prototype</span>: <span class="string">&#x27;对象新原型或null&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果修改成功， <code>setPrototypeOf</code>方法返回 <code>true</code>，否则返回 <code>false</code></li><li>如果<code>target</code>不可扩展，原型参数必须与<code>Object.setPropertyOf(target)</code>的值相同</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json</title>
      <link href="/blog//package-json/"/>
      <url>/blog//package-json/</url>
      
        <content type="html"><![CDATA[<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><center>package.json</center></h2>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Garbage Collecation</title>
      <link href="/blog//JavaScript-Garbage-Collecation/"/>
      <url>/blog//JavaScript-Garbage-Collecation/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-Garbage-Collecation（垃圾回收）"><a href="#JavaScript-Garbage-Collecation（垃圾回收）" class="headerlink" title="JavaScript Garbage Collecation（垃圾回收）"></a><center>JavaScript Garbage Collecation（垃圾回收）</center></h2><h4 id="1-垃圾回收定义"><a href="#1-垃圾回收定义" class="headerlink" title="1. 垃圾回收定义"></a>1. 垃圾回收定义</h4><p>  找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><h4 id="2-JS垃圾回收机制"><a href="#2-JS垃圾回收机制" class="headerlink" title="2. JS垃圾回收机制"></a>2. JS垃圾回收机制</h4><ul><li><p>标记清除</p><p>  JavaScript中最常用的垃圾回收方式。当变量进入执行环境标记为“进入环境”，离开环境将其标记为“离开环境”，等待清除</p></li><li><p>引用计数</p><p>  语言引擎存在一张“引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数，如果一个值的引用次数是0，就表示这个值不再被使用了，因此可以将这块内存释放</p><p>  引用计数的问题：循环引用</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  obj1.<span class="property">next</span> = obj2</span><br><span class="line">  obj2.<span class="property">next</span> = obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当函数执行结束后，返回值为<code>undefined</code>，所以整个函数以及内部变量都应该被回收，但是根据引用计数方法，<code>obj1</code> 和 <code>obj2</code> 的引用次数都不为0，所以它们不会被回收，解决循环引用的办法：不使用它们的时候手动将它们设为<code>null</code></p></li></ul><h4 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h4><ul><li><p>意外的全局变量</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>; <span class="comment">// 定义成了全局对象(window)属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="number">0</span> <span class="comment">// this指向了全局对象(window)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用严格模式可以避免意外的全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>被遗忘的计时器或回调函数</p></li><li><p>闭包</p></li><li><p>没有清理的DOM元素引用</p></li></ul><h4 id="4-避免内存泄漏的一些方式"><a href="#4-避免内存泄漏的一些方式" class="headerlink" title="4. 避免内存泄漏的一些方式"></a>4. 避免内存泄漏的一些方式</h4><ul><li>减少不必要的全局变量或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li><li>注意程序逻辑，避免“死循环”</li><li>避免创建过多的对象，不使用的时候手动将它们设为null</li></ul><h4 id="5-垃圾回收使用场景优化"><a href="#5-垃圾回收使用场景优化" class="headerlink" title="5. 垃圾回收使用场景优化"></a>5. 垃圾回收使用场景优化</h4><ul><li><p>数组优化</p><p>  将<code>空数组[]</code>赋值给数组对象是清空数组的捷径，但是<code>空数组</code>也会占用内存。实际上<code>array.length = 0</code>也能清空数组，并且同时能实现数组重用，减少内存垃圾产生</p></li><li><p>对象尽量复用</p><p>  对象尽量复用，不用的对象尽可能设置为null，尽快被垃圾回收掉</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index Signature</title>
      <link href="/blog//Index-Signature/"/>
      <url>/blog//Index-Signature/</url>
      
        <content type="html"><![CDATA[<h2 id="Index-Signature"><a href="#Index-Signature" class="headerlink" title="Index Signature"></a><center>Index Signature</center></h2><h4 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h4><p>  你有两个对象，分别描述了两个工作人员的工资：<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> salary1 = &#123;</span><br><span class="line">  <span class="attr">baseSalary</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">yearlyBonus</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> salary2 = &#123;</span><br><span class="line">  <span class="attr">contractSalary</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  之后，你想实现一个函数，根据工作人员的工资信息得到总薪资</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">totalSalary</span>(<span class="params">salaryObject: ???</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> salaryObject) &#123;</span><br><span class="line">    total += salaryObject[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">totalSalary</span>(salary1); <span class="comment">// 30</span></span><br><span class="line"><span class="title function_">totalSalary</span>(salary2); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>  看起来函数似乎可以正常工作，<code>salaryObject</code>被<code>typescript</code>推断为any，这时候我们可以传入任何对象。当我们传入的对象值的类型不为<code>number</code>时，此函数将会在运行时报错（比如：<code>&#123; baseSalary: true &#125;</code>）</p><p>  这个时候应该如果定义<code>totalSalary</code>函数的参数<code>totalSalary</code>的类型注解呢？答案是<code>Index Signature</code>（索引签名），接下来我们来看看如何在<code>Typescript</code>中使用索引签名，以及何时需要它</p><h4 id="2-什么是索引签名？"><a href="#2-什么是索引签名？" class="headerlink" title="2. 什么是索引签名？"></a>2. 什么是索引签名？</h4><p>  当你不确定对象属性的名称，只知道属性和值的类型，这时可以使用索引签名来描述。</p><p>  比如<code>salaryObject</code>，我们可以确定属性的类型（<code>string</code>）、值的类型（<code>number</code>），但我们不知道具体的属性名。便可以使用索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> salaryType = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此类型描述了一个以字符串类型作为属性，数字类型作为值的对象。当我们传入非<code>number</code>类型的属性值对象时，<code>typescript</code>将会提示错误</p><h4 id="3-索引签名语法"><a href="#3-索引签名语法" class="headerlink" title="3. 索引签名语法"></a>3. 索引签名语法</h4><p>  索引签名语法非常简单，只需要在方括号内写下属性的类型：<code>&#123; [key: keyType]: valueType &#125;</code>，一些例子：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在第二个例子<code>Iss</code>中，我们还定义了一个<code>name</code>属性，标识此类型对象上必须要有一个<code>name</code>属性，但这里有一个限制，索引签名强制要求所有的属性值必须为索引签名的属性值相匹配（或子类型），否则，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  ~~name~~: <span class="built_in">boolean</span> <span class="comment">// Error: Property &#x27;name&#x27; of type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，索引签名属性只允许使用：string、number、symbol、template string（模板字符串）以及只包含这些类型的联合类型</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: ~~<span class="built_in">boolean</span>~~]: <span class="built_in">string</span> <span class="comment">// Error: An index signature parameter type must be &#x27;string&#x27;, &#x27;number&#x27;, &#x27;symbol&#x27;, or a template literal type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-索引签名注意事项"><a href="#4-索引签名注意事项" class="headerlink" title="4. 索引签名注意事项"></a>4. 索引签名注意事项</h4><ul><li><p>访问一个不存在的对象</p><p>当我们视图访问索引签名<code>&#123; [key: string]: string &#125;</code>对象上不存在的对象时，会发生什么？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>正如索引签名定义的那样，<code>Typescript</code>将会把<code>obj.a</code>推断为<code>string</code>，但我们知道，在运行时<code>obj.a</code>实际为<code>undefined</code></p><p>索引签名只会将属性类型映射到值类型，值类型可能会偏离实际允许时的数据，这部分需要根据实际代码自行处理。当然，你也可以将值类型增加<code>undefined</code>类型，这样<code>Typescript</code>会提示你访问的属性可能不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string | undefined</span></span><br></pre></td></tr></table></figure></li><li><p><code>string</code>和<code>number</code>类型属性</p><p>  当我们定义一个以数字为<code>key</code>的对象，我们可以直接定义为：<code>[key: string]: string</code>，如：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;one&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 obj[&#x27;1&#x27;] 或 obj[1] 访问</span></span><br><span class="line"><span class="keyword">const</span> val1 = obj[<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> val2 = obj[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>  为什么我们定义时<code>key</code>的类型为<code>string</code>，但确可以通过<code>number</code>访问，<code>Typescript</code>也不会提示错误呢？</p><p>  因为<code>JavaScript</code>在访问对象时，会隐式的将数字强制转换为字符串（<code>obj[1]</code>→ <code>obj[&#39;1&#39;]</code>），这意味着访问<code>obj[1]</code>和<code>obj[&#39;1&#39;]</code>是一样的，<code>Typescript</code>也执行这种隐式转换。因此我们可以同时定义两种类型的索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同样也要注意，数字类型属性值必须与字符串类型属性值的相匹配（或子类型）</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: ~~<span class="built_in">boolean</span>~~ <span class="comment">// Error: &#x27;number&#x27; index type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-索引签名与Record"><a href="#5-索引签名与Record" class="headerlink" title="5. 索引签名与Record"></a>5. 索引签名与Record</h4><p>  <code>Typescript</code>提供了一个实用类型<code>Record</code>：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>  它与索引签名类似，那么我们如何区分何时使用索引签名，何时使用<code>Record</code>呢？</p><p>  正如我们前面所提到的，索引签名对属性类型定义存在限制（索引签名属性类型只允许：string、number、symbol、template string）。当我们尝试在索引签名字面量类型或字面量联合类型，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [~~key~~: <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.</span></span><br></pre></td></tr></table></figure><p>  但我们可以通过<code>Record</code>定义：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Is</span> =  &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lemon&#x27;</span>,</span><br><span class="line">  <span class="attr">hobby</span>: <span class="string">&#x27;program&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以，建议使用索引签名来注释通用对象（当我们只知道属性的类型和属性值的类型时）。但当我们知道具体的属性时，建议使用<code>Record&lt;keys, Type&gt;</code>来注释特定对象</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li>索引签名的语法：<code>[key: KeyType]: ValueType</code>，其中<code>KeyType</code>类型只允许：<code>string、number、symbol、template string</code>，而<code>ValueType</code>可以是任何类型</li><li>当你不知道要注释的对象的具体结构（具体的属性名），但你知道属性名的类型和属性值的类型，那你可能需要的就是索引签名</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new.target</title>
      <link href="/blog//new-target/"/>
      <url>/blog//new-target/</url>
      
        <content type="html"><![CDATA[<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a><center>new.target</center></h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p><code>new.target</code>属性（ES6引入）允许你检测函数或构造方法是否通过<code>new</code>运算符进行调用。通过new运算符被初始化的函数或构造方法时，<code>new.target</code>返回一个指向构造方法或函数的引用，在普通的函数调用中，<code>new.target</code>返回<code>undefined</code></p></blockquote><p>  注意：</p><ul><li>在<code>arrow function</code>中，没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，<code>new.target</code>指向最近的外层函数的<code>new.target</code></li><li>在子类继承父类时，<code>new.target</code>指向初始化类的类定义，即子类</li></ul><h4 id="2-在ES5中如何限制函数通过new运算符调用"><a href="#2-在ES5中如何限制函数通过new运算符调用" class="headerlink" title="2. 在ES5中如何限制函数通过new运算符调用"></a>2. 在ES5中如何限制函数通过<code>new</code>运算符调用</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>this</code>将指向构造函数实例</p></li><li><p>普通调用函数，非严格模式<code>this</code>指向<code>window</code>，严格模式指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Window &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以通过判断<code>this</code>是否当前构造函数的实例，来判断是否通过<code>new</code>运算符调用，使用<code>this instanceof [构造函数]</code>，通过<code>new</code>调用返回<code>true</code>，普通调用返回<code>false</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 不建议使用 arguments.callee.name，在严格模式下arguments属性被移除</span></span><br><span class="line">  <span class="keyword">if</span>(!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Instance</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>()  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>但通过此方法判断并不完全准确，如果调用时通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向，将<code>this</code>指向构造函数实例，以上方法将无效</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()))  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-new-target"><a href="#3-new-target" class="headerlink" title="3. new.target"></a>3. new.target</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>new.target</code>指向构造方法或函数的引用</p></li><li><p>普通调用函数，<code>new.target</code>指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span>.<span class="property">target</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以使用<code>new.target</code>来限制构造函数必须通过<code>new</code>运算符调用</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变this指向</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>())) <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-使用new-target模拟实现抽象类"><a href="#4-使用new-target模拟实现抽象类" class="headerlink" title="4. 使用new.target模拟实现抽象类"></a>4. 使用<code>new.target</code>模拟实现抽象类</h4><ul><li><p>因为当子类继承父类时，<code>new.target</code>指向初始化类的类定义</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">P</span>() <span class="comment">// class P &#123; constructor() &#123; console.log(new.target) &#125; &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">S</span>() <span class="comment">// class S extends P &#123; constructor() &#123; super() &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>利用这一特性，可以模拟实现抽象类</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === P) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&#x27;Cannot create an instance of an abstract class.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">P</span>()) <span class="comment">// Uncaught SyntaxError: Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">S</span>()) <span class="comment">// S &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul><li>在ES5中，通过<code>new</code>运算符调用时<code>this</code>指向构造函数实例，普通调用时<code>this</code>在非严格模式指向<code>window</code>，严格模式指向<code>undefined</code>，利用这一特性，结合<code>this instanceof [构造函数]</code>，可以判断是否通过<code>new</code>运算符调用构造函数，但此方法并不安全，可以通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向</li><li>在ES6中，引入<code>new.target</code>属性，通过<code>new</code>运算符调用时<code>new.target</code>指向构造方法或函数的引用，普通调用函数，<code>new.target</code>指向<code>undefined</code>，可以通过此属性判断是否通过<code>new</code>运算符调用构造函数</li><li>利用<code>new.target</code>属性，可以模拟实现抽象类</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Preflight request</title>
      <link href="/blog//Preflight-request/"/>
      <url>/blog//Preflight-request/</url>
      
        <content type="html"><![CDATA[<h2 id="Preflight-request（预检请求）"><a href="#Preflight-request（预检请求）" class="headerlink" title="Preflight request（预检请求）"></a><center>Preflight request（预检请求）</center></h2><h4 id="1-什么是预检请求？"><a href="#1-什么是预检请求？" class="headerlink" title="1. 什么是预检请求？"></a>1. 什么是预检请求？</h4><blockquote><p>一个<code>CORS</code>预检请求是用于检查服务器是否支持<code>CORS</code>（跨域资源共享），由浏览器自动通过<code>OPTIONS</code>方法发起（<strong>非简单请求</strong>才会发起预检请求）。当预检请求完成，服务器确认允许后，才发起实际的HTTP请求。</p></blockquote><h4 id="2-简单请求与非简单请求"><a href="#2-简单请求与非简单请求" class="headerlink" title="2. 简单请求与非简单请求"></a>2. 简单请求与非简单请求</h4><ul><li><p>简单请求</p><ul><li>请求方法：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>请求首部字段只包含：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type<ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul></li></ul></li><li>如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器；也就是说，给定一个XMLHttpRequest实例xhr，没有调用xhr.upload.addEventListener()，以监听该上传请求</li><li>请求中没有使用ReadableStream对象</li></ul></li><li><p>非简单请求</p><ul><li>不满足简单请求的都是非简单请求</li></ul></li></ul><h4 id="3-预检请求中的请求首部字段"><a href="#3-预检请求中的请求首部字段" class="headerlink" title="3. 预检请求中的请求首部字段"></a>3. 预检请求中的请求首部字段</h4><ul><li>Origin：请求源URL（不包含路径）</li><li>Access-Control-Request-Method：实际请求所使用的HTTP方法</li><li>Access-Control-Request-Headers：实际请求时携带的自定义首部字段</li></ul><img src="/blog/Preflight-request/request-header.png" class="" title="Preflight request header"><h4 id="4-预见请求中的响应首部字段"><a href="#4-预见请求中的响应首部字段" class="headerlink" title="4. 预见请求中的响应首部字段"></a>4. 预见请求中的响应首部字段</h4><ul><li>Access-Control-Allow-Origin：允许该源访问资源地址，可以使用<code>*</code>通配符，表示任意源（仅当不需要携带<code>Cookie</code>时，如果携带<code>Cookie</code>，必须指定具体的源地址，否则将会请求失败）</li><li>Access-Control-Allow-Methods：允许使用的HTTP方法</li><li>Access-Control-Allow-Headers：允许使用的请求首部字段</li><li>Access-Control-Allow-Credentials：是否允许携带Cookie</li><li>Access-Control-Expose-Headers：<code>XMLHttpRequest</code>对象的 <code>getResponseHeader()</code>方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头</li><li>Access-Control-Max-Age：指定预检请求缓存时间，单位为秒，默认5秒</li></ul><img src="/blog/Preflight-request/response-header.png" class="" title="Preflight response header"><h4 id="5-完整请求流程图"><a href="#5-完整请求流程图" class="headerlink" title="5. 完整请求流程图"></a>5. 完整请求流程图</h4><img src="/blog/Preflight-request/request-flow.png" class="" title="request flow">]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用内置符号(well-known symbol)</title>
      <link href="/blog//%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7-well-known-symbol/"/>
      <url>/blog//%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7-well-known-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="常用内置符号-well-known-symbol"><a href="#常用内置符号-well-known-symbol" class="headerlink" title="常用内置符号(well-known symbol)"></a><center>常用内置符号(well-known symbol)</center></h2><p>  ES6引入了一批常用内置符合（well-known symbol）用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为</p><ul><li>内置符号以Symbol工厂函数字符串属性的形式存在</li><li>内置符号的主要用途之一是<strong>重新定义</strong>，从而改变原生结构的行为</li><li>内置符号没有特别之处，它们就是全局函数Symbol的普通字符串属性，指向一个符号的实例</li><li><strong>所有内置符号属性都是不可写（writeable: false），不可枚举（enumerable: false），不可配置（configurable: false）</strong></li></ul><p>  <strong>目前公有13个内置符号</strong></p><h4 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="Symbol.Iterator"></a><strong><code>Symbol.Iterator</code></strong></h4><p>  <code>Symbol.iterator</code>为每一个对象定义了默认的迭代器。</p><p>  示例：</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">idx</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> range = <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...range) <span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></code></pre><p>  一些拥有默认定义迭代器的内置类型：**<code>Array</code>、<code>TypedArray</code>、<code>String</code>、<code>Map</code>、<code>Set</code>**</p><h4 id="Symbol-asyncIterator"><a href="#Symbol-asyncIterator" class="headerlink" title="Symbol.asyncIterator"></a><strong><code>Symbol.asyncIterator</code></strong></h4><p>  <code>Symbol.asyncIterator</code>符号指定了一个对象的默认异步迭代器</p><p>  示例：</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">idx</span>++)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> r <span class="keyword">of</span> <span class="keyword">new</span> Range(<span class="number">5</span>)</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r) <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a><strong><code>Symbol.hasInstance</code></strong></h4><p>  <code>Symbol.hasInstance</code>用于判断某对象是否为某构造器的实例。因此你可以用它自定义 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a>操作符在某个类上的行为。</p><p>  ES6中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系，所以直接调用<code>Symbol.hasInstance</code>与使用<code>instanceof</code>操作符是一样的</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](a)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>  </code></pre><p>  <code>Symbol.hasInstance</code>属性定义在<code>Function</code>原型上，因此默认所有函数和类上都可以使用。也可以在类上<strong>通过静态方法重新定义</strong>这个函数</p><p>  <code>Symbol.hasInstance</code>返回一个<code>Boolean</code>, 如果返回的不是<code>Boolean</code>, 会将<code>Flasy</code>转换为<code>false</code>, 其余为<code>true</code></p><pre><code>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Surpass10</span> &#123;</span><br><span class="line">  <span class="comment">// 注意要使用静态方法，否则无法访问到此方法</span></span><br><span class="line">  <span class="comment">// Symbol.hasInstance返回一个Boolean, 如果返回的不是Boolean, 会将Flasy转换为false, 其余为true</span></span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](value) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(value) &amp;&amp; value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span> <span class="keyword">instanceof</span> <span class="title class_">Surpass10</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span> <span class="keyword">instanceof</span> <span class="title class_">Surpass10</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><strong><code>Symbol.isConcatSpreadable</code></strong></h4><p>  <code>Symbol.isConcatSpreadable</code>符号用于配置某对象作为<code>Array.prototype.concat()</code>方法的参数时是否展开其数组元素</p><p>  数组默认<code>true</code>，类数组（<code>ArrayLike</code>）默认<code>false</code></p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">concat</span>(b)) <span class="comment">// [ 1, 2, 3, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">b[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">concat</span>(b)) <span class="comment">// [ 1, 2, 3, [ 3, 4, 5, [Symbol(Symbol.isConcatSpreadable)]: false ] ]</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a><strong><code>Symbol.match</code></strong></h4><p>  <code>Symbol.match</code>指定了匹配的是正则表达式而不是字符串。<code>String.prototype.match()</code>方法会调用此函数</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooMatcher</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123;</span><br><span class="line">    <span class="comment">// String.includes 用于查找字符串是否包含此字符串，返回布尔值</span></span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新定义Symbol.match() 函数 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringMatcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="variable language_">this</span>.<span class="property">str</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个String为总字符串，第二个String为要查找的字符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-matchAll"><a href="#Symbol-matchAll" class="headerlink" title="Symbol.matchAll"></a><strong><code>Symbol.matchAll</code></strong></h4><p>  <code>String.prototype.matchAll()</code>方法会调用此函数</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;2016-01-02|2019-03-07&quot;</span></span><br><span class="line"><span class="keyword">const</span> numbers = &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">matchAll</span>](str) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> str.<span class="title function_">matchAll</span>(<span class="regexp">/[0-9]+/g</span>)) <span class="keyword">yield</span> n[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(str.<span class="title function_">matchAll</span>(numbers))) <span class="comment">// [ &#x27;2016&#x27;, &#x27;01&#x27;, &#x27;02&#x27;, &#x27;2019&#x27;, &#x27;03&#x27;, &#x27;07&#x27; ]</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a><strong><code>Symbol.replace</code></strong></h4><p>  <code>Symbol.replace</code>这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。<code>String.prototype.replace()</code>方法会调用此方法</p><p>  <code>Symbol.replace</code>接收两个参数，调用 replace()方法的字符串实例和替换字符串</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Replace1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="built_in">string</span>, replace) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`s/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/<span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span>/<span class="subst">$&#123;replace&#125;</span>/g`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">Replace1</span>(<span class="string">&#x27;bar&#x27;</span>), <span class="string">&#x27;zoo&#x27;</span>)) <span class="comment">// s/foo/bar/zoo/g</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a><strong><code>Symbol.search</code></strong></h4><p>  <code>Symbol.search</code> 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 <code>String.prototype.search()</code></p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">caseInsensitiveSearch</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">search</span>](<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title function_">caseInsensitiveSearch</span>(<span class="string">&#x27;BaR&#x27;</span>))) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a><strong><code>Symbol.species</code></strong></h4><p>  <code>Symbol.species</code> 符号属性表示“一个函数值，该函数作为创建派生对象的构造函数”；这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="comment">// 覆盖 species 到父级的 Array 构造函数上</span></span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> mapped = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">MyArray</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">Array</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a><strong><code>Symbol.split</code></strong></h4><p>  <code>Symbol.split</code>指向 一个正则表达式的索引处分割字符串的方法。这个方法通过 <code>String.prototype.split()</code>调用</p><p>  <code>Symbol.split</code>函数接收一个参数，调用<code>match()</code>方法的字符串实例</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Split1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">split</span>](<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">string</span>.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>.substr(<span class="number">0</span>, index)&#125;</span>/<span class="subst">$&#123;<span class="built_in">string</span>.substr(index + <span class="variable language_">this</span>.value.length)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">Split1</span>(<span class="string">&#x27;foo&#x27;</span>)))</span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><strong><code>Symbol.toPrimitive</code></strong></h4><p>  <code>Symbol.toPrimitive</code>是内置的 symbol 属性，其指定了一种接受首选类型并返回对象原始值的表示的方法。它被所有的强类型转换制算法优先调用</p><p>  在 <code>Symbol.toPrimitive</code>属性（用作函数值）的帮助下，对象可以转换为一个原始值。该函数被调用时，会被传递一个字符串参数 <code>hint</code>，表示要转换到的原始值的预期类型。<code>hint</code>参数的取值是 <code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>和 <code>&quot;default&quot;</code>中的任意一个</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj) <span class="comment">// 10  — hint 参数值是 &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>) <span class="comment">// &quot;hello&quot;   — hint 参数值是 &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;true&quot;    — hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a><strong><code>Symbol.toStringTag</code></strong></h4><p>  <code>Symbol.toStringTag</code>用于创建对象的默认字符串描述。它由 <code>Object.prototype.toString()</code>方法内部访问</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidatorClass</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Validator&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">ValidatorClass</span>())) <span class="comment">// &#x27;[object Validator]&#x27;</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a><strong><code>Symbol.unscopables</code></strong></h4><p>  <code>Symbol.unscopables</code>指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">property1</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">property2</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object1[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123;</span><br><span class="line">  <span class="attr">property2</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (object1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(property1) <span class="comment">// 42</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(property2) <span class="comment">// Expected output: Error: property1 is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol</title>
      <link href="/blog//Symbol/"/>
      <url>/blog//Symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><center>Symbol</center></h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>  ES6引入了一种新的原始数据类型<code>symbol</code>，表示独一无二的值。它属于JavaScript语言的数据类型之一</p><p>  八大数据类型：<code>Symbol、undefined、null、Boolean、String、Number、Bigint、Object</code></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不要使用new命令，由于Symbol值不是对象，所以不能添加属性</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol值不能与其他类型的值进行预算，会报错</span></span><br><span class="line"></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;s&#125;</span>`</span> <span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是Symbol值可以显示转为字符串</span></span><br><span class="line"><span class="title class_">String</span>(s) <span class="comment">// &#x27;Symbol(feature)&#x27;</span></span><br><span class="line">s.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(feature)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以转为布尔值</span></span><br><span class="line"><span class="title class_">Boolean</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-作为属性名的Symbol"><a href="#2-作为属性名的Symbol" class="headerlink" title="2. 作为属性名的Symbol"></a>2. 作为属性名的<code>Symbol</code></h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[symbol] = <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [symbol]: <span class="string">&#x27;hello!&#x27;</span>  <span class="comment">// 方括号为ES6计算属性（computedPropertyName）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, symbol, &#123;&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>()</span><br></pre></td></tr></table></figure><p>  注意：<code>Symbol</code> 值作为对象属性名时，不能用点运算符（ES6的动态属性只在方括号中生效，而点<code>.</code>运算符后面总是字符串）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sy]: <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">sy</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[sy]) <span class="comment">// &#x27;feature&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-遍历属性名"><a href="#3-遍历属性名" class="headerlink" title="3. 遍历属性名"></a>3. 遍历属性名</h4><p>  <code>Symbol</code> 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>()</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>() <span class="comment">//Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名</span></span><br></pre></td></tr></table></figure><h4 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h4><ul><li><p><code>Symbol.prototype.description</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Symbol对象的描述</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line">s.<span class="property">descriotion</span> <span class="comment">// &quot;feature&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.for()</code>：注意会被登记到全局环境，可以在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p> 注意：</p><ul><li><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code></li><li><code>Symbol.for()</code>会被登记到全局环境，<code>Symbol()</code>不会</li><li><code>Symbol.for()</code>会先检查给定的<code>key</code>是否已经存在,如果不存在则创建一个新的<code>Symbol</code>，存在就返回这个<code>Symbol</code>值</li></ul></li><li><p><code>Symbol.keyFor()</code>：返回被<code>Symbol.for()</code>注册到全局<code>Symbol</code>类型值的<code>key</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;feature&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1) <span class="comment">// &quot;feature&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;feature&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-常用实例"><a href="#5-常用实例" class="headerlink" title="5. 常用实例"></a>5. 常用实例</h4><ul><li><p>消除魔术字符串：魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;circle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见解决方法：使用变量</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">circle</span>: <span class="string">&#x27;circle&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.<span class="property">circle</span>: <span class="comment">// 使用变量</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Symbol，定义的变量的属性值并不重要，只是为了区分</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">circle</span>: <span class="title class_">Symbol</span>() <span class="comment">// 使用Symbol</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESModule与CommonJS模块化规范</title>
      <link href="/blog//ESModule%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <url>/blog//ESModule%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="ESModule与CommonJS模块化规范"><a href="#ESModule与CommonJS模块化规范" class="headerlink" title="ESModule与CommonJS模块化规范"></a><center>ESModule与CommonJS模块化规范</center></h2><p>JavaScript 的模块化一直是一个比较棘手的问题。在 ES6 之前，JavaScript 没有内置的模块化机制，这导致了开发者需要使用一些其他的方式来管理代码的依赖关系，例如使用 IIFE（立即执行函数）等方式来实现模块化编程。这些方式虽然可以实现代码的模块化，但是代码的可读性和可维护性并不是很好。</p><p>在 ES6 中，JavaScript 引入了模块化规范，这使得我们可以更加方便地管理代码的依赖关系，提高代码的可重用性和可维护性。ES6 引入了一种新的模块化规范，即 ESModule（ES6 Module），与之前的 CommonJS 模块化规范有一些区别。</p><h3 id="ESModule-模块化规范"><a href="#ESModule-模块化规范" class="headerlink" title="ESModule 模块化规范"></a>ESModule 模块化规范</h3><p>ESModule 是 ES6 中引入的一种模块化规范，它的设计目标是实现一个先进的、可靠的、可静态分析的模块化系统，以适应 JavaScript 在大型项目中的复杂性。</p><h4 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h4><p>ESModule 中使用 <code>import</code> 和 <code>export</code> 关键字来进行导入和导出。导入和导出的语法非常简洁明了，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ESModule 中，每个模块都是一个独立的文件，每个文件中可以有多个导入和导出。使用 ESModule 进行模块化编程可以使得代码的可读性和可维护性大大提高，同时也可以提高代码的重用性。</p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>ESModule 中的导入和导出是静态分析的，这意味着它可以在编译时分析依赖关系，从而进行一些优化。例如，可以将导入的模块转换为常量，从而提高代码的执行效率。</p><h4 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h4><p>ESModule 中的每个模块都具有自己的顶级作用域，这意味着每个模块中的变量和函数都不会污染全局命名空间。这可以使得代码的可读性和可维护性大大提高，同时也可以避免命名冲突等问题。</p><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><p>CommonJS 是一种比较成熟的 JavaScript 模块化规范，它最初是为 Node.js 设计的，但是现在也可以在浏览器中使用。CommonJS 中使用 <code>require</code> 和 <code>module.exports</code> 关键字来进行导入和导出。与 ESModule 不同的是，CommonJS 中的导入和导出是动态的，这意味着它是在运行时解析的，而不是在编译时解析的。</p><h4 id="导入和导出-1"><a href="#导入和导出-1" class="headerlink" title="导入和导出"></a>导入和导出</h4><p>CommonJS 中使用 <code>require</code> 函数来导入模块，使用 <code>module.exports</code> 对象来导出模块。导入和导出的语法相对 ESModule 来说较为繁琐，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CommonJS 中，每个模块也是一个独立的文件，每个文件中可以有多个导入和导出。与 ESModule 不同的是，CommonJS 中的导入和导出是动态的，这意味着在运行时需要对每个模块进行解析，这会导致一些性能问题。</p><h4 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h4><p>由于 CommonJS 中的导入和导出是动态的，所以它具有一些动态特性，例如可以在运行时动态加载模块。这些特性在某些场景下是非常有用的，但是在一些其他场景下也可能会导致一些问题，例如因为动态特性导致代码无法进行静态分析，从而无法进行优化。</p><h3 id="ESModule-与-CommonJS-的区别"><a href="#ESModule-与-CommonJS-的区别" class="headerlink" title="ESModule 与 CommonJS 的区别"></a>ESModule 与 CommonJS 的区别</h3><p>虽然 ESModule 和 CommonJS 都是 JavaScript 的模块化规范，但是它们之间存在一些区别，主要包括以下几个方面：</p><h4 id="导入和导出的语法"><a href="#导入和导出的语法" class="headerlink" title="导入和导出的语法"></a>导入和导出的语法</h4><p>ESModule 使用 <code>import</code> 和 <code>export</code> 关键字来进行导入和导出，而 CommonJS 使用 <code>require</code> 和 <code>module.exports</code> 关键字来进行导入和导出。ESModule 的语法相对简洁明了，而 CommonJS 的语法相对较为繁琐。</p><h4 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h4><p>ESModule 中的导入和导出是静态分析的，可以在编译时分析依赖关系，并进行一些优化。而 CommonJS 中的导入和导出是动态的，需要在运行时进行解析。这导致 ESModule 具有更好的性能和可维护性。</p><h4 id="顶级作用域-1"><a href="#顶级作用域-1" class="headerlink" title="顶级作用域"></a>顶级作用域</h4><p>ESModule 中的每个模块都具有自己的顶级作用域，而 CommonJS 中的模块共享全局作用域。这意味着 ESModule 中的变量和函数不会污染全局命名空间，而 CommonJS 中可能会存在命名冲突等问题。</p><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>ESModule 中不允许循环依赖，如果出现循环依赖会报错。而 CommonJS 中可以处理循环依赖，但是会存在一些问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ESModule 和CommonJS 都是 JavaScript 的模块化规范，它们都具有各自的优缺点和适用场景。ESModule 具有更好的性能和可维护性，适用于需要大规模管理的项目和需要进行静态分析的场景；而 CommonJS 具有动态特性，适用于需要动态加载模块的场景。</p><p>在实际开发中，我们可以根据具体的情况选择不同的模块化方案。如果我们正在开发一个 Node.js 项目，可以使用 CommonJS 规范来进行模块化；如果我们正在开发一个大规模的 Web 应用，可以使用 ESModule 规范来进行模块化。</p><p>总的来说，模块化是现代化 JavaScript 开发的重要组成部分，它可以提高代码的可维护性、可重用性和可扩展性，使得 JavaScript 应用程序更加易于开发和维护。无论是 ESModule 还是 CommonJS，它们都是非常重要的 JavaScript 模块化规范，值得我们深入了解和学习。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
