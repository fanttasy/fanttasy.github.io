<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript中的命名空间和模块</title>
      <link href="/blog//TypeScript%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
      <url>/blog//TypeScript%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript中的命名空间和模块"><a href="#TypeScript中的命名空间和模块" class="headerlink" title="TypeScript中的命名空间和模块"></a><center>TypeScript中的命名空间和模块</center></h2><p>TypeScript是一种面向对象的编程语言，它提供了类、接口、枚举等面向对象编程的特性，同时还支持对JavaScript的增强，例如类型检查、泛型等功能。在大型项目中，为了更好的组织代码和提高代码的可维护性，TypeScript提供了命名空间和模块的概念。本文将深入讨论TypeScript中的命名空间和模块。</p><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>命名空间是一种将相关的代码组织在一起的机制。在TypeScript中，命名空间可以被认为是一种逻辑上的分组，它将代码组织成一个独立的单元，避免了命名冲突和代码重复的问题。</p><h2 id="命名空间的语法"><a href="#命名空间的语法" class="headerlink" title="命名空间的语法"></a>命名空间的语法</h2><p>命名空间的语法非常简单，可以通过以下方式定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="comment">// Code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>MyNamespace</code>是命名空间的名称。在命名空间内部，可以定义变量、函数、类等代码。</p><h2 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h2><p>要使用命名空间中的代码，需要使用<code>namespace</code>关键字，后跟命名空间名称和代码的路径。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyNamespace</span>.<span class="title class_">MyClass</span>()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了一个名为<code>MyNamespace</code>的命名空间，并在其中定义了一个名为<code>MyClass</code>的类。然后，我们通过<code>MyNamespace.MyClass</code>来实例化这个类。</p><p>需要注意的是，如果没有使用<code>export</code>关键字将类或其他代码暴露给外部，则它将不可访问。</p><h2 id="命名空间的嵌套"><a href="#命名空间的嵌套" class="headerlink" title="命名空间的嵌套"></a>命名空间的嵌套</h2><p>命名空间可以嵌套，这使得代码组织更加灵活。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">MySubNamespace</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyNamespace</span>.<span class="property">MySubNamespace</span>.<span class="title class_">MyClass</span>()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们在<code>MyNamespace</code>命名空间中嵌套了<code>MySubNamespace</code>命名空间，并在其中定义了一个名为<code>MyClass</code>的类。要实例化这个类，我们可以使用<code>MyNamespace.MySubNamespace.MyClass</code>。</p><h2 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a>命名空间的别名</h2><p>命名空间可以通过<code>import</code>语句进行别名。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyNamespaceAlias</span> = <span class="title class_">MyNamespace</span></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyNamespaceAlias</span>.<span class="title class_">MyClass</span>()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>import</code>语句将<code>MyNamespace</code>命名空间别名为<code>MyNamespaceAlias</code>。然后，我们可以使用<code>MyNamespaceAlias</code>来访问<code>MyNamespace</code>中的代码。</p><h2 id="命名空间的限制"><a href="#命名空间的限制" class="headerlink" title="命名空间的限制"></a>命名空间的限制</h2><p>在使用命名空间时，需要注意以下几点：</p><ul><li>命名空间中的代码只能在命名空间内</li><li>命名空间中的代码无法直接访问全局变量和函数，必须通过<code>window</code>对象来访问</li><li>在使用命名空间时，应该避免使用<code>var</code>关键字定义变量，而应该使用<code>let</code>或<code>const</code>关键字</li></ul><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在TypeScript中，模块是一种将相关的代码组织在一起的机制，类似于命名空间。但是，模块比命名空间更加灵活，它可以在不同的文件中定义，同时也支持依赖管理和代码共享。</p><h2 id="模块的语法"><a href="#模块的语法" class="headerlink" title="模块的语法"></a>模块的语法</h2><p>模块的语法非常简单，可以通过以下方式定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个名为<code>MyClass</code>的类，并使用<code>export</code>关键字将其暴露给外部。</p><h2 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h2><p>要使用模块中的代码，需要使用<code>import</code>语句，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyClass</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>import</code>语句从<code>my-module</code>模块中导入<code>MyClass</code>类，并使用它来实例化一个对象。</p><p>需要注意的是，如果没有使用<code>export</code>关键字将类或其他代码暴露给外部，则它将不可访问。</p><h2 id="模块的导出方式"><a href="#模块的导出方式" class="headerlink" title="模块的导出方式"></a>模块的导出方式</h2><p>模块可以通过多种方式进行导出。</p><h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>默认导出是一种特殊的导出方式，它允许我们将一个模块中的单个代码元素（如类、函数或变量）导出为默认的导出。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>export default</code>关键字将<code>MyClass</code>类定义为默认导出。这意味着，当我们从这个模块中导入内容时，我们可以使用任何名称来引用默认导出。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyCustomClassName</span> <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyCustomClassName</span>()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将<code>MyClass</code>类作为默认导出，并将其命名为<code>MyCustomClassName</code>。</p><h3 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h3><p>命名导出允许我们将一个模块中的多个代码元素（如类、函数或变量）导出为命名导出。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myVariable = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个名为<code>MyClass</code>的类，一个名为<code>myFunction</code>的函数，以及一个名为<code>myVariable</code>的常量，并使用<code>export</code>关键字将它们全部导出。</p><p>在导入时，我们需要使用对应的名称来引用每个命名导出。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyClass</span>, myFunction, myVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"><span class="title function_">myFunction</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVariable)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>import</code>语句从<code>my-module</code>模块中导入<code>MyClass</code>类、<code>myFunction</code>函数和<code>myVariable</code>常量，并在代码中使用它们。</p><h2 id="模块的导入方式"><a href="#模块的导入方式" class="headerlink" title="模块的导入方式"></a>模块的导入方式</h2><p>在TypeScript中，模块可以通过多种方式进行导入。</p><h3 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h3><p>命名导入是一种使用花括号语法从模块中导入多个命名导出的方式。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyClass</span>, myFunction, myVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用花括号语法从<code>my-module</code>模块中导入<code>MyClass</code>类、<code>myFunction</code>函数和<code>myVariable</code>常量，并将它们分别赋值给变量。</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>默认导入是一种使用不带花括号的语法从模块中导入默认导出的方式。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyCustomClassName</span> <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用不带花括号的语法从<code>my-module</code>模块中导入默认导出，并将其命名为<code>MyCustomClassName</code>。</p><h3 id="组合导入"><a href="#组合导入" class="headerlink" title="组合导入"></a>组合导入</h3><p>组合导入是一种从模块中同时导入默认导出和命名导出的方式。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyCustomClassName</span>, &#123; myFunction, myVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./my-module&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用组合导入的方式从<code>my-module</code>模块中导入默认导出和<code>myFunction</code>函数以及<code>myVariable</code>常量。</p><h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><p>在使用模块时，TypeScript需要知道如何解析和加载模块。有两种主要的模块解析策略：</p><ul><li>Node.js解析策略</li><li>经典解析策略</li></ul><h3 id="Node-js解析策略"><a href="#Node-js解析策略" class="headerlink" title="Node.js解析策略"></a>Node.js解析策略</h3><p>Node.js解析策略是一种将模块解析为Node.js风格的策略，它使用以下规则来解析模块：</p><ul><li>如果路径以<code>./</code>或<code>../</code>开头，则解析为相对路径</li><li>如果路径以<code>/</code>开头，则解析为绝对路径</li><li>如果路径不以<code>./</code>、<code>../</code>或<code>/</code>开头，则解析为Node.js模块</li></ul><h3 id="经典解析策略"><a href="#经典解析策略" class="headerlink" title="经典解析策略"></a>经典解析策略</h3><p>经典解析策略是一种将模块解析为经典JavaScript风格的策略，它使用以下规则来解析模块：</p><ul><li>如果路径以<code>./</code>或<code>../</code>开头，则解析为相对路径</li><li>如果路径以<code>/</code>开头，则解析为服务器根目录的相对路径</li><li>如果路径不以<code>./</code>、<code>../</code>或<code>/</code>开头，则解析为全局模块</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命名空间和模块是TypeScript中两个不同的组织代码的机制，它们各自有各自的用途和优缺点。命名空间适用于组织相对简单的代码库，而模块适用于组织复杂的代码库和多人协作开发的项目。命名空间是一种将相关的代码组织在一起的方式，它通过将代码包装在命名空间中来避免命名冲突和代码污染。而模块则是一种将代码封装和抽象化的方式，它通过将相关的代码放在一个独立的文件或文件夹中来组织代码。</p><p>当我们使用命名空间时，我们需要使用<code>namespace</code>关键字来定义命名空间，并使用<code>export</code>关键字来导出命名空间中的变量、函数和类。当我们使用模块时，我们需要使用<code>export</code>关键字来导出模块中的变量、函数和类，并使用<code>import</code>语句来导入模块中的内容。</p><p>在模块的使用中，我们可以使用命名导入、默认导入和组合导入等不同的方式来导入模块中的内容。在模块解析方面，TypeScript提供了Node.js解析策略和经典解析策略两种解析方式，开发者可以根据具体的项目需求来选择合适的解析方式。</p><p>最后，我们需要注意的是，在使用TypeScript时，我们应该根据项目的需求来选择合适的组织代码的方式。无论是使用命名空间还是模块，都需要遵循良好的代码组织原则和最佳实践，以确保代码的可读性、可维护性和可扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预编译与变量提升</title>
      <link href="/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译与变量提升"><a href="#预编译与变量提升" class="headerlink" title="预编译与变量提升"></a><center>预编译与变量提升</center></h2><h4 id="1-JavaScript执行三部曲"><a href="#1-JavaScript执行三部曲" class="headerlink" title="1. JavaScript执行三部曲"></a>1. JavaScript执行三部曲</h4><ul><li>语法分析</li><li>预编译</li><li>解析执行</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h4><ul><li>JavaScript预编译发生在代码片段执行前，分为<code>全局预编译（GO: Global Object）</code>、<code>函数预编译（AO: Activation Object）</code>，全局预编译发生在<code>script</code>标签引入执行时（全局作用域），函数预编译发生在函数执行前一刻（函数作用域）。预编译会创建当前环境的执行上下文。</li><li>预编译发生在<code>变量声明</code>和<code>函数声明</code>，<code>匿名函数</code>和<code>函数表达式</code>不进行预编译</li></ul><h4 id="3-Imply-global（暗示全局变量）"><a href="#3-Imply-global（暗示全局变量）" class="headerlink" title="3. Imply global（暗示全局变量）"></a>3. Imply global（暗示全局变量）</h4><p>  任何变量未经声明就赋值，此变量就变为<code>全局对象（window，globalThis）</code>所有</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123; a = <span class="number">2</span> &#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="4-全局预编译"><a href="#4-全局预编译" class="headerlink" title="4. 全局预编译"></a>4. 全局预编译</h4><ul><li>创建<code>GO（Global Object）</code></li><li>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 变量声明）</li></ul><h4 id="5-全局预编译过程"><a href="#5-全局预编译过程" class="headerlink" title="5. 全局预编译过程"></a>5. 全局预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = z = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">y = <span class="title function_">add</span>(x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">z = <span class="title function_">add</span>(x)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>GO</code></p></li><li><p>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Go</span>&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GO</span>&#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">add</span>: <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">1</span> &#125; =&gt; <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-函数预编译"><a href="#6-函数预编译" class="headerlink" title="6. 函数预编译"></a>6. 函数预编译</h4><ul><li>创建<code>AO（Activation Object）</code></li><li>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>将实参值与形参统一</li><li>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 实参 &gt; 变量声明）</li></ul><h4 id="7-函数预编译过程"><a href="#7-函数预编译过程" class="headerlink" title="7. 函数预编译过程"></a>7. 函数预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">fn</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>AO</code></p></li><li><p>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将实参值与形参统一</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">d</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-变量提升（Hoisting）"><a href="#8-变量提升（Hoisting）" class="headerlink" title="8. 变量提升（Hoisting）"></a>8. 变量提升（<code>Hoisting</code>）</h4><p>  在预编译过程中，<code>变量声明</code>，<code>函数声明</code>会被移到调用前，从而产生<code>变量提升</code></p><ul><li><p><code>函数声明</code>整体提升，无论函数调用和声明的位置是前是后，总会被函数声明移到调用前，函数名与形参或变量名同名时：<code>函数声明</code> &gt; <code>实参</code> &gt; <code>变量声明</code></p></li><li><p><code>匿名函数</code>和<code>函数表达式</code>不会提升</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// undefined: 变量提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()) <span class="comment">// not defined: 函数表达式不会提升</span></span><br></pre></td></tr></table></figure></li><li><p><code>变量声明</code>提升，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p></li><li><p><code>var</code>：<code>创建</code>和<code>初始化</code>都被提升</p></li><li><p><code>function</code>：整体提升，<code>创建</code>、<code>初始化</code>、<code>赋值</code>都提升</p></li><li><p><code>let</code>、<code>const</code>：<code>创建</code>提升（即变量已存在，但只有等到变量声明语句执行后才能使用）</p></li><li><p>ES6 <code>import</code>具有提升效果，导入模块会提升到整个模块的头部，首先执行（<code>import</code>静态编译，<code>import()</code>，<code>require()</code>动态加载）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-暂时性死区（Temporal-dead-zone，简称TDZ）"><a href="#9-暂时性死区（Temporal-dead-zone，简称TDZ）" class="headerlink" title="9. 暂时性死区（Temporal dead zone，简称TDZ）"></a>9. 暂时性死区（Temporal dead zone，简称TDZ）</h4><p>  <code>暂时性死区</code>本质是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明语句执行后，才可以获取和使用该变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 死区陷阱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> x <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> z <span class="comment">// Reference Error</span></span><br><span class="line"><span class="keyword">let</span> z</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Surrogate Pair</title>
      <link href="/blog//Surrogate-Pair/"/>
      <url>/blog//Surrogate-Pair/</url>
      
        <content type="html"><![CDATA[<h2 id="Surrogate-Pair"><a href="#Surrogate-Pair" class="headerlink" title="Surrogate Pair"></a><center>Surrogate Pair</center></h2><p>  什么是<code>Surrogate Pair</code>呢？在我了解到它的时候，我只是在Google搜索”<code>如何在JavaScript中获取字符串的最后一位</code>“，于是我得到了下面几种方式，先让我们看看这几种方式</p><h4 id="获取字符串的最后一位的几种方式"><a href="#获取字符串的最后一位的几种方式" class="headerlink" title="获取字符串的最后一位的几种方式"></a>获取字符串的最后一位的几种方式</h4><ul><li><p>substring、substr</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>charAt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>split</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li><li><p>Array.from()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li><li><p>Spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...str].<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></li></ul><h4 id="几种方式处理字符串"><a href="#几种方式处理字符串" class="headerlink" title="几种方式处理字符串"></a>几种方式处理字符串</h4><p>  以上几种方式处理字符串正常情况下（如英文字符串）都没有什么问题，让我们来看看执行结果<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;example&#x27;</span></span><br><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">[...str].<span class="title function_">pop</span>() <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><br>  所有方式都能正确获取字符串的最后一位，但当我们我们字符串中出现<code>Surrogate Pair</code>时（比如emoji），让我们来看看会发生什么<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;example💩&#x27;</span></span><br><span class="line">str.<span class="title function_">substr</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">substring</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>) <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)[str.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line">str.<span class="title function_">match</span>(<span class="regexp">/.$/</span>).<span class="title function_">pop</span>() <span class="comment">// &#x27;\uDCA9&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">pop</span>() <span class="comment">// &#x27;💩&#x27;</span></span><br><span class="line">[...str].<span class="title function_">pop</span>() <span class="comment">// &#x27;💩&#x27;</span></span><br></pre></td></tr></table></figure><br>  这个结果让是否让你感到费解？接下来让我们了解一下原因吧</p><h4 id="Surrogate-Pair-1"><a href="#Surrogate-Pair-1" class="headerlink" title="Surrogate Pair"></a>Surrogate Pair</h4><ul><li><p>什么是Surrogate Pair</p><p>在Unicode字符集中，有一些字符的码点需要超过16位才能表示。因此，Unicode定义了一种机制，用于将这些字符分成两个16位编码单元。这些编码单元被称为代理项（Surrogate）。一个代理项由两个编码单元组成：高代理项和低代理项。高代理项的编码单元在范围0xD800到0xDBFF之间，而低代理项的编码单元在范围0xDC00到0xDFFF之间</p><p>例如，表情符号😀（U+1F600）是由两个编码单元组成的代理对表示的。高代理项为0xD83D，低代理项为0xDE00。这两个编码单元组成的代理对表示的是一个单个的Unicode字符</p></li><li><p>JavaScript中的Surrogate Pair</p><p>JavaScript使用UTF-16编码，当JavaScript遇到代理对时，它将其解释为两个单独的字符，而不是一个字符，这意味着，如果您正在处理包含代理对的字符串，您需要考虑到这些特殊字符，以确保正确处理字符串中的每个字符</p><p>在处理包含代理对的字符串时，需要注意字符串的长度和索引。由于代理对是由两个16位编码单元组成的，所以当代理对出现在字符串中时，该字符串的长度将增加2而不是1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;💩&#x27;</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>此外，在字符串中使用索引访问代理对时需要注意。因为代理对的第一个编码单元在字符串中的索引位置必须是偶数，而第二个编码单元在字符串中的索引位置必须是奇数</p><p>因此，在使用以上几种方式处理<code>Surrogate Pair</code>时，一些方法不能正确进行处理</p></li></ul><h4 id="如何正确处理Surrogate-Pair？"><a href="#如何正确处理Surrogate-Pair？" class="headerlink" title="如何正确处理Surrogate Pair？"></a>如何正确处理<code>Surrogate Pair</code>？</h4><p>  在上面的几种方式中，我们也看到了如何正确处理<code>Surrogate Pair</code></p><ul><li><p>Array.from()</p><p>使用Array.from()能正确的将所有字符串按照你想要的方式处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀hello💩&#x27;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(str) <span class="comment">// [&#x27;😀&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;💩&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Spread<br>同样使用Spread(扩展运算符)也能进行处理</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;😀hello💩&#x27;</span></span><br><span class="line">[...str] <span class="comment">// [&#x27;😀&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;💩&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  <code>Surrogate Pair</code>是Unicode字符集中的一些字符，由于其码点超过了16位，因此被拆分为两个16位编码单元。在JavaScript中，由于字符串是UTF-16编码，因此代理对被解释为两个单独的字符。在处理包含代理对的字符串时，需要注意字符串的长度和索引</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
          <category> JavaScript </category>
          
          <category> Unicode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Type &#39;string&#39; is not assignable to type in TypeScript</title>
      <link href="/blog//Type-string-is-not-assignable-to-type-in-TypeScript/"/>
      <url>/blog//Type-string-is-not-assignable-to-type-in-TypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="Type-‘string’-is-not-assignable-to-type-in-Typescript"><a href="#Type-‘string’-is-not-assignable-to-type-in-Typescript" class="headerlink" title="Type ‘string’ is not assignable to type in Typescript"></a><center>Type ‘string’ is not assignable to type in Typescript</center></h2><h4 id="Type-‘string’-is-not-assignable-to-type-in-Typescript-1"><a href="#Type-‘string’-is-not-assignable-to-type-in-Typescript-1" class="headerlink" title="Type ‘string’ is not assignable to type in Typescript"></a>Type ‘string’ is not assignable to type in Typescript</h4><p>  当<code>Typescript</code>出现<code>&quot;Type &#39;string&#39; is not assignable to type&quot;</code>错误时，一般情况是我们将<code>string</code>类型分配给了看起来是字符串类型，其实并不是完整的字符串类型。如<code>literal type(字面量)</code>或者<code>enum(枚举)</code><br>  <br /><br>  解决这个问题其实比较简单，使用常量(const)定义或者类型断言</p><p>  如:<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// yellow: string</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></p><p>  在上例中，变量<code>yellow</code>类型为<code>string</code>,而<code>current</code>类型为<code>PrimaryColor</code>。当我们将<code>string</code>分配给<code>PrimaryColor</code>时就会出现此错误，这是因为，虽然<code>yellow</code>变量的值为<code>PrimaryColor</code>其中之一，但是它是<code>string</code>类型，对<code>PrimaryColor</code>来说太过广泛</p><p>  换句话来说，<code>PrimaryColor</code>只存在三个值<code>&#39;red&#39;</code>、<code>&#39;yellow&#39;</code>、<code>&#39;green&#39;</code>，而string类型可以为任意字符串</p><p>  解决办法：</p><ul><li><p>类型断言(type assertion)</p><p>如上例，我们可以使用类型断言将<code>yellow</code>断言为<code>PrimaryColor</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// yellow: PrimaryColor</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="title class_">PrimaryColor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li><li><p>const断言(const assertion)</p><p>使用const assertion将变量<code>yellow</code>断言为字符串字面量<code>&#39;yellow&#39;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yellow: &#x27;yellow&#x27;</span></span><br><span class="line"><span class="keyword">let</span> yellow = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li><li><p>使用const定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yellow: &#x27;yellow&#x27;</span></span><br><span class="line"><span class="keyword">const</span> yellow = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">PrimaryColor</span> = yellow</span><br></pre></td></tr></table></figure></li></ul><p>  一些其他情况</p><ul><li><p>接下来看看另外一个例子</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Letter</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Letter</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">letter</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">letter</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;Letter&#x27;.</span></span><br><span class="line">arr.<span class="title function_">push</span>(obj.<span class="property">letter</span>)</span><br></pre></td></tr></table></figure><p>因为数组<code>arr</code>类型为<code>Letter[]</code>,而<code>obj.letter</code>类型为<code>string</code>,因此发生错误。</p><p>解决办法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Letter</span> = <span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Letter</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123; <span class="attr">letter</span>: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">letter</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type assertion</span></span><br><span class="line">arr.<span class="title function_">push</span>(obj.<span class="property">letter</span> <span class="keyword">as</span> <span class="title class_">Letter</span>)</span><br></pre></td></tr></table></figure><p>如果可以，最好将<code>obj.letter</code>在定义时直接定义为<code>Letter</code>类型</p></li><li><p>还有一个例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: string[]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string[]&#x27; is not assignable to type &#x27;PrimaryColor[]&#x27;.</span></span><br><span class="line"><span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure><p>原因是<code>arr2</code>类型为<code>string[]</code>，不能将其赋值给<code>PrimaryColor[]</code>，可以使用<code>const assertion</code>解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: readonly [&quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure><p>但是<code>const assertion</code>会将数组转化为只读元组类型，如果你后续想要修改数组中的类型将会发生错误，所以这种方法不适合数组需要修改的情况，可以使用<code>type assertion</code>解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;yellow&#x27;</span> | <span class="string">&#x27;green&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2: PrimaryColor[]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;yellow&#x27;</span>] <span class="keyword">as</span> <span class="title class_">PrimaryColor</span>[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr3</span>: <span class="title class_">PrimaryColor</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr4</span>: <span class="title class_">PrimaryColor</span>[] = [...arr2, ...arr3]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Type-string-is-not-assignable-to-type-Enum-in-Typescript"><a href="#Type-string-is-not-assignable-to-type-Enum-in-Typescript" class="headerlink" title="Type string is not assignable to type Enum in Typescript"></a>Type string is not assignable to type Enum in Typescript</h4><p>  另一种常见情况出现在枚举<code>Enum</code><br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;&quot;yellow&quot;&#x27; is not assignable to type &#x27;PrimaryColor&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color</span>: <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;yellow&#x27;</span></span><br></pre></td></tr></table></figure><br>  解决办法<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">  red = <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  yellow = <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  green = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color1</span>: <span class="title class_">PrimaryColor</span> = <span class="title class_">PrimaryColor</span>.<span class="property">yellow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">color2</span>: <span class="title class_">PrimaryColor</span> = <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">as</span> <span class="title class_">PrimaryColor</span></span><br></pre></td></tr></table></figure></p><h4 id="Type-‘X’-is-not-assignable-to-type-‘Y’-in-Typescript"><a href="#Type-‘X’-is-not-assignable-to-type-‘Y’-in-Typescript" class="headerlink" title="Type ‘X’ is not assignable to type ‘Y’ in Typescript"></a>Type ‘X’ is not assignable to type ‘Y’ in Typescript</h4><p>  这种情况出现赋值时左边的变量与右侧的值具有不兼容的类型，解决办法可以通过<code>type assertion(类型断言)</code>或<code>type guard(类型守卫)</code>在赋值之前比较两个值是否具有兼容性</p><p>  如下例：<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name: string</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;lemox&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">name = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>  变量<code>name</code>初始化时被typescript推断为<code>string</code>类型，当我们将<code>number</code>类型分配给<code>name</code>时就会发生错误。解决办法是确保两个值具有兼容性或者使用类型断言</p><p>  使用联合类型定义变量<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name: string | number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&#x27;lemox&#x27;</span></span><br><span class="line"></span><br><span class="line">name = <span class="number">100</span></span><br></pre></td></tr></table></figure><br>  有时你可能知道两个值具有兼容性，但是typescript不知道，这时你可以使用<code>type assertion(类型断言)</code></p><p>  还有<br>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = person.<span class="property">name</span></span><br></pre></td></tr></table></figure><br>  由于<code>person.name</code>为可选属性，即存在两种类型<code>string | undefined</code>，因此类型不兼容，可以使用类型断言或类型守卫解决</p><ul><li><p>类型断言</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = person.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span></span><br></pre></td></tr></table></figure><p>可以使用类型断言明确的告诉<code>typescript</code>，当前上下文<code>person.name</code>为<code>string</code></p></li><li><p>类型守卫<br>更好的办法是使用类型守卫</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">country</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bobby Hadz&#x27;</span>,</span><br><span class="line">  <span class="attr">country</span>: <span class="string">&#x27;Chile&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="keyword">typeof</span> person.<span class="property">name</span> === <span class="string">&#x27;string&#x27;</span> ? person.<span class="property">name</span> : <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样可以确保我们总是给<code>name</code>分配了一个字符串</p></li><li><p>还有一种常见错误</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;number | undefined&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">first</span>: <span class="built_in">number</span> = result</span><br></pre></td></tr></table></figure><p>因为<code>Array.pop()</code>方法的返回值可能为<code>undefined</code>，所以我们不能直接将其分配给<code>number</code>类型，可以使用以上提到的方式解决</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num1</span>: <span class="built_in">number</span> = result <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num2</span>: <span class="built_in">number</span> | <span class="literal">undefined</span> = result</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型守卫</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">num3</span>: <span class="built_in">number</span> = result ?? <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  要解决<code>Type &#39;X&#39; is not assignable to type &#39;Y&#39;</code>问题，主要是需要确保两边值类型的兼容性，如果两个值兼容性不匹配，则会发生错误</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript中的逆变与协变</title>
      <link href="/blog//Typescript%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/"/>
      <url>/blog//Typescript%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Typescript中的逆变与协变"><a href="#Typescript中的逆变与协变" class="headerlink" title="Typescript中的逆变与协变"></a><center>Typescript中的逆变与协变</center></h2><p>  TypeScript 是一门静态类型语言，具有丰富的类型系统特性，其中逆变和协变是两个重要的概念。它们在 TypeScript 中用于描述函数类型、泛型和类继承等场景中的类型转换关系</p><h4 id="什么是逆变和协变"><a href="#什么是逆变和协变" class="headerlink" title="什么是逆变和协变"></a>什么是逆变和协变</h4><p>  在 TypeScript 中，逆变和协变是两个类型转换的方向。逆变用于从更具体的类型转换为更一般的类型，而协变则用于从更一般的类型转换为更具体的类型</p><p>  换句话说，逆变和协变都是用来描述类型之间的包含关系。逆变意味着一个更具体的类型可以替代一个更一般的类型，而协变意味着一个更一般的类型可以替代一个更具体的类型</p><p>  例如，我们有两个类型 A 和 B，如果 A 是 B 的子类型，那么 A 就是更具体的类型，B 就是更一般的类型。逆变和协变分别描述了从 A 到 B 和从 B 到 A 的类型转换关系</p><h4 id="TypeScript中的逆变"><a href="#TypeScript中的逆变" class="headerlink" title="TypeScript中的逆变"></a>TypeScript中的逆变</h4><p>  在 TypeScript 中，逆变通常发生在函数参数的类型转换中。当函数参数的类型需要比函数签名中声明的类型更具体时，就需要使用逆变</p><p>  例如，我们有一个函数 f，它接收一个类型为 B 的参数，并返回一个类型为 A 的结果。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要接收一个类型为 A 的参数，那么我们需要使用逆变。我们可以将 f 函数的参数类型从 B 转换为 A 的超类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">b: B</span>): A &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: b.<span class="property">name</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="function">(<span class="params">a: A</span>) =&gt;</span> A = f <span class="comment">// 使用逆变，将 B 转换为 A 的超类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数 f 接收一个类型为 B 的参数，并返回一个类型为 A 的结果。我们将这个函数赋值给变量 g，并且需要将 B 类型的参数转换为 A 类型，以满足 g 变量的类型要求</p><h4 id="TypeScript中的协变"><a href="#TypeScript中的协变" class="headerlink" title="TypeScript中的协变"></a>TypeScript中的协变</h4><p>  协变通常发生在函数返回值的类型转换中。当函数返回值的类型需要比函数签名中声明的类型更具体时，就需要使用协变</p><p>  例如，我们有一个函数 f，它返回一个类型为 A 的结果，但实际上它返回的是一个类型为 B 的实例，其中 B 是 A 的子类型。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要返回一个类型为 B 的结果，那么我们需要使用协变。我们可以将 f 函数的返回值类型从 A 转换为 B 的子类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>): A &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="function">() =&gt;</span> B = f <span class="comment">// 使用协变，将 A 转换为 B 的子类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数 f 返回一个类型为 A 的结果，实际上它返回的是一个类型为 B 的实例。我们将这个函数赋值给变量 g，并且需要将返回值类型从 A 转换为 B 的子类型，以满足 g 变量的类型要求</p><h4 id="TypeScript中的泛型逆变和协变"><a href="#TypeScript中的泛型逆变和协变" class="headerlink" title="TypeScript中的泛型逆变和协变"></a>TypeScript中的泛型逆变和协变</h4><p>  在 TypeScript 中，逆变和协变也可以应用于泛型类型参数。当一个泛型类型参数需要比其声明的类型更具体时，就需要使用逆变；当一个泛型类型参数需要比其声明的类型更一般时，就需要使用协变</p><p>  例如，我们有一个泛型函数 f，它接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组。如果我们要将这个函数赋值给一个变量 g，并且这个变量需要接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，那么我们需要使用逆变。我们可以将泛型类型参数 T 的类型从 <code>Array&lt;B&gt;</code> 转换为 <code>Array&lt;A&gt;</code> 的超类型，以满足变量 g 的要求</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> f&lt;T <span class="keyword">extends</span> B&gt;(<span class="attr">arr</span>: <span class="title class_">Array</span>&lt;T&gt;): <span class="title class_">Array</span>&lt;A&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">name</span>: item.<span class="property">name</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: &lt;T <span class="keyword">extends</span> A&gt;<span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;T&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;A&gt; = f <span class="comment">// 使用逆变，将 Array&lt;B&gt; 转换为 Array&lt;A&gt; 的超类型</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。泛型函数 f 接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组。我们将这个函数赋值给变量 g，并且需要将泛型类型参数 T 的类型从 <code>Array&lt;B&gt;</code> 转换为 <code>Array&lt;A&gt;</code> 的超类型，以满足变量 g 的类型要求</p><p>  另外，需要注意的是，在 TypeScript 中，函数参数和返回值是可以同时具有逆变和协变的</p><p>  例如，我们有一个函数类型 Func，它接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;B&gt;</code> 的数组。如果我们要将这个函数类型赋值给一个变量 f，并且这个变量需要接收一个类型为 <code>Array&lt;B&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;A&gt;</code> 的数组，那么我们需要同时使用逆变和协变</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;A&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;B&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>: <span class="function">(<span class="params">arr: <span class="built_in">Array</span>&lt;B&gt;</span>) =&gt;</span> <span class="title class_">Array</span>&lt;A&gt; = (<span class="attr">arr</span>: <span class="title class_">Array</span>&lt;B&gt;): <span class="title class_">Array</span>&lt;A&gt; =&gt;</span><br><span class="line">  arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">name</span>: item.<span class="property">name</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">g</span>: <span class="title class_">Func</span> = f <span class="comment">// 同时使用逆变和协变，将参数类型从 Array&lt;B&gt; 转换为 Array&lt;A&gt;，将返回值类型从 Array&lt;A&gt; 转换为 Array&lt;B&gt;</span></span><br></pre></td></tr></table></figure><p>  在上面的代码中，我们定义了两个接口 A 和 B，其中 B 继承自 A。函数类型 Func 接收一个类型为 <code>Array&lt;A&gt;</code> 的数组，并返回一个类型为 <code>Array&lt;B&gt;</code> 的数组。我们将函数 f 赋值给变量 g，并且需要同时使用逆变和协变，以满足变量 g 的类型要求</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  在 TypeScript 中，逆变和协变是非常有用的类型系统特性。它们可以帮助我们更好地理解和设计函数和类型。逆变和协变的区别在于，逆变是指一个类型可以被替换为其超类型，而协变是指一个类型可以被替换为其子类型。在 TypeScript 中，逆变和协变可以应用于函数参数类型、函数返回值类型和泛型类型参数</p><p>  使用逆变和协变可以帮助我们编写更灵活、更通用的代码，同时也可以帮助我们更好地理解和设计接口和类型。在使用逆变和协变时，我们需要注意类型安全性和代码的可读性，以避免出现潜在的错误和困惑</p><p>  希望这篇博客能够帮助你更好地理解 TypeScript 中的逆变和协变，并在实际开发中应用它们</p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy</title>
      <link href="/blog//Proxy/"/>
      <url>/blog//Proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><center>Proxy</center></h2><h4 id="1-Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义"><a href="#1-Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义" class="headerlink" title="1. Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义"></a>1. <code>Proxy</code>对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><ul><li><p>target</p><p>要使用<code>Proxy</code>包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</p></li><li><p>handler</p><p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code>的行为</p><p>如果<code>handler</code>没有设置任何拦截行为，那就等同于直接通向原对象</p></li></ul><h4 id="2-要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object-proxy属性，从而可以在对象上调用）"><a href="#2-要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object-proxy属性，从而可以在对象上调用）" class="headerlink" title="2. 要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作（可以将Proxy对象设置到对象object.proxy属性，从而可以在对象上调用）"></a>2. 要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例进行操作，而不是针对目标对象进行操作（可以将<code>Proxy</code>对象设置到对象<code>object.proxy</code>属性，从而可以在对象上调用）</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">time</span>) <span class="comment">// &#x27;proxy&#x27;</span></span><br></pre></td></tr></table></figure><p>  <code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p><h4 id="3-Proxy-revocable-：创建一个可撤销的Proxy对象"><a href="#3-Proxy-revocable-：创建一个可撤销的Proxy对象" class="headerlink" title="3. Proxy.revocable()：创建一个可撤销的Proxy对象"></a>3. <code>Proxy.revocable()</code>：创建一个可撤销的<code>Proxy</code>对象</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler)</span><br><span class="line"></span><br><span class="line">proxy <span class="comment">// 对象：代理实例</span></span><br><span class="line"><span class="title function_">revoke</span>() <span class="comment">// 函数：取消代理，执行revoke()后再访问就会报错</span></span><br></pre></td></tr></table></figure><h4 id="4-this问题"><a href="#4-this问题" class="headerlink" title="4. this问题"></a>4. <code>this</code>问题</h4><p>  在<code>Proxy</code>代理的情况下，目标对象内部的<code>this</code>关键字会指向<code>Proxy</code>代理，而拦截函数<code>this</code>指向<code>handler</code>对象</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hander</span></span><br><span class="line">    target[prop] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// target</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// proxy</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;lemon&#x27;</span></span><br></pre></td></tr></table></figure><p>  此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以<code>Proxy</code>也无法代理这些原生对象的属性</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>()</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><h4 id="5-handler对象的方法（目前标准的是13种）"><a href="#5-handler对象的方法（目前标准的是13种）" class="headerlink" title="5. handler对象的方法（目前标准的是13种）"></a>5. <code>handler</code>对象的方法（目前标准的是13种）</h4><ul><li><code>get(target, prop, receiver)</code>：属性读取操作的捕捉器</li><li><code>set(target, prop, value, receiver)</code>：属性设置操作的捕捉器，返回一个布尔值</li><li><code>has(target, prop)</code>：<code>in</code>操作符的捕捉器，返回一个布尔值</li><li><code>deleteProperty(target, property)</code>：<code>delete</code>操作符的捕捉器，返回一个布尔值</li><li><code>ownKeys(target)</code>：<code>Object.getOwnPropertyNames</code>方法和 <code>Object.getOwnPropertySymbols</code>方法的捕捉器，返回一个数组</li><li><code>getOwnPropertyDescriptor(target, prop)</code>：<code>Object.getOwnPropertyDescriptor</code>方法的捕捉器，返回属性的描述对象</li><li><code>defineProperty(target, property, descriptor)</code>：<code>Object.defineProperty</code>方法的捕捉器，返回一个布尔值</li><li><code>preventExtensions(target)</code>：<code>Object.preventExtensions</code>方法的捕捉器，返回一个布尔值</li><li><code>getPrototypeOf(target)</code>：<code>Object.getPrototypeOf</code>方法的捕捉器，返回一个布尔值</li><li><code>setPrototypeOf(target, prototype)</code>：<code>Object.setPrototypeOf</code>方法的捕捉器，返回一个布尔值</li><li><code>isExtensible(target)</code>：<code>Object.isExtensible</code>方法的捕捉器，返回一个布尔值</li><li><code>apply(target, thisArg, argumentsList)</code>：函数调用操作的捕捉器</li><li><code>construct(target, argumentsList, newTarget)</code>：<code>new</code>操作符的捕捉器，返回一个对象</li></ul><h4 id="6-实例"><a href="#6-实例" class="headerlink" title="6. 实例"></a>6. 实例</h4><ul><li><p><code>get(target, prop, receiver)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">receiver</span>: <span class="string">&#x27;Proxy或者继承Proxy的对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象的属性不可配置<code>configurable: false</code>且不可写<code>writable: false</code>，则<code>Proxy</code>不能修改该属性，通过<code>Proxy</code>访问该属性会报错</li><li>如果目标属性没有配置访问方法，即get方法为<code>undefined</code>，则返回值必须为<code>undefined</code></li></ul></li><li><p><code>set(target, prop, value, receiver)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;属性值&#x27;</span>, <span class="attr">receiver</span>: <span class="string">&#x27;Proxy实例本身&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象的属性不可写<code>writable: false</code>，则<code>set</code>方法无效</li><li>返回<code>Boolean</code>值，<code>true</code>设置成功，<code>false</code>设置失败（严格模式<code>false</code>会报错）</li><li>如果目标属性没有配置储存方法，即<code>set</code>方法为<code>undefined</code>，则不能设置值</li></ul></li><li><p><code>apply(target, thisArg, argumentsList)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">thisArg</span>: <span class="string">&#x27;目标对象的上下文对象（this）&#x27;</span>, <span class="attr">argumentsList</span>: <span class="string">&#x27;参数数组&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> twice = &#123;</span><br><span class="line">  apply (target, thisArg, argumentsList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice)</span><br><span class="line"><span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>target</code>必须是可以被调用的，即必须是一个函数对象</li></ul></li><li><p><code>has(target, prop)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果目标对象不可扩展，使用<code>has</code>拦截就会报错</li><li>如果目标对象的某一属性本身不可被配置，使用<code>has</code>拦截就会报错</li></ul></li><li><p><code>construct(target, argumentsList, newTarget)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象（函数）&#x27;</span>, <span class="attr">argumentsList</span>: <span class="string">&#x27;参数数组&#x27;</span>, <span class="attr">newTarget</span>: <span class="string">&#x27;new 命令作用的构造函数&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：返回值必须是一个对象，否则会报错，由于<code>construct()</code>拦截构造函数，所以目标对象必须是函数</p></li><li><p><code>deleteProperty(target, property)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>deleteProperty</code>必须返回一个 <code>Boolean</code>类型的值，表示了该属性是否被成功删除</li><li>如果目标对象属性不可配置<code>configurable: false</code>，不能被删除，就会报错</li></ul></li><li><p><code>defineProperty(target, property, descriptor)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">property</span>: <span class="string">&#x27;属性名&#x27;</span>, <span class="attr">descriptor</span>: <span class="string">&#x27;待定义或修改的属性的描述符&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>defineProperty</code>方法必须以一个 <code>Boolean</code>返回，表示定义该属性的操作成功与否（严格模式返回<code>false</code>会报错）</li><li>如果目标对象不可扩展（<code>non-extensible</code>），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错</li><li>如果目标对象属性不可写<code>writable</code>或不可配置<code>configurable</code>，则<code>defineProperty()</code>方法不能改变这两个设置</li></ul></li><li><p><code>getOwnPropertyDescriptor(target, prop)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;属性名&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>getOwnPropertyDescriptor</code>必须返回一个<code>object</code>或<code>undefined</code></li></ul></li><li><p><code>getPrototypeOf(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>getPrototypeOf()</code>必须返回对象或者<code>null</code>，否则会报错</li><li>如果目标对象不可扩展（<code>non-extensible</code>），<code>getPrototypeOf()</code>方法必须返回目标对象的原型对象</li></ul></li><li><p><code>isExtensible(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>isExtensible()</code>必须返回布尔值，否则返回值会被自动转为布尔值，且返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则会保持</li></ul></li><li><p><code>ownKeys(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>自动过滤，不会返回（1. 不存在的属性 2. Symbol属性 3. 不可遍历<code>enumerable</code>属性）</li><li><code>ownkeys()</code>方法返回的数组成员，只能是字符串或<code>Symbol</code>值，其他类型或者根本不是数组就会报错</li><li>如果目标对象包含不可配置的属性，则该属性必须被<code>ownkeys()</code>返回，否则会报错</li><li>如果目标对象不可扩展（<code>non-extensible</code>），<code>ownkeys()</code>必须返回原对象的所有属性，且不能包含多余的属性，否则会报错</li></ul></li><li><p><code>preventExtensions(target)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>preventExtensions()</code>有一个限制，只有当目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>只能返回<code>true</code>，否则会报错</li><li><code>preventExtensions()</code>返回一个布尔值</li></ul></li><li><p><code>setPrototypeOf(target, prototype)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Params</span> = &#123; <span class="attr">target</span>: <span class="string">&#x27;目标对象&#x27;</span>, <span class="attr">prototype</span>: <span class="string">&#x27;对象新原型或null&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果修改成功， <code>setPrototypeOf</code>方法返回 <code>true</code>，否则返回 <code>false</code></li><li>如果<code>target</code>不可扩展，原型参数必须与<code>Object.setPropertyOf(target)</code>的值相同</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json</title>
      <link href="/blog//package-json/"/>
      <url>/blog//package-json/</url>
      
        <content type="html"><![CDATA[<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><center>package.json</center></h2>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Garbage Collecation</title>
      <link href="/blog//JavaScript-Garbage-Collecation/"/>
      <url>/blog//JavaScript-Garbage-Collecation/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-Garbage-Collecation（垃圾回收）"><a href="#JavaScript-Garbage-Collecation（垃圾回收）" class="headerlink" title="JavaScript Garbage Collecation（垃圾回收）"></a><center>JavaScript Garbage Collecation（垃圾回收）</center></h2><h4 id="1-垃圾回收定义"><a href="#1-垃圾回收定义" class="headerlink" title="1. 垃圾回收定义"></a>1. 垃圾回收定义</h4><p>  找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><h4 id="2-JS垃圾回收机制"><a href="#2-JS垃圾回收机制" class="headerlink" title="2. JS垃圾回收机制"></a>2. JS垃圾回收机制</h4><ul><li><p>标记清除</p><p>  JavaScript中最常用的垃圾回收方式。当变量进入执行环境标记为“进入环境”，离开环境将其标记为“离开环境”，等待清除</p></li><li><p>引用计数</p><p>  语言引擎存在一张“引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数，如果一个值的引用次数是0，就表示这个值不再被使用了，因此可以将这块内存释放</p><p>  引用计数的问题：循环引用</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  obj1.<span class="property">next</span> = obj2</span><br><span class="line">  obj2.<span class="property">next</span> = obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当函数执行结束后，返回值为<code>undefined</code>，所以整个函数以及内部变量都应该被回收，但是根据引用计数方法，<code>obj1</code> 和 <code>obj2</code> 的引用次数都不为0，所以它们不会被回收，解决循环引用的办法：不使用它们的时候手动将它们设为<code>null</code></p></li></ul><h4 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h4><ul><li><p>意外的全局变量</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>; <span class="comment">// 定义成了全局对象(window)属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="number">0</span> <span class="comment">// this指向了全局对象(window)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用严格模式可以避免意外的全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>被遗忘的计时器或回调函数</p></li><li><p>闭包</p></li><li><p>没有清理的DOM元素引用</p></li></ul><h4 id="4-避免内存泄漏的一些方式"><a href="#4-避免内存泄漏的一些方式" class="headerlink" title="4. 避免内存泄漏的一些方式"></a>4. 避免内存泄漏的一些方式</h4><ul><li>减少不必要的全局变量或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li><li>注意程序逻辑，避免“死循环”</li><li>避免创建过多的对象，不使用的时候手动将它们设为null</li></ul><h4 id="5-垃圾回收使用场景优化"><a href="#5-垃圾回收使用场景优化" class="headerlink" title="5. 垃圾回收使用场景优化"></a>5. 垃圾回收使用场景优化</h4><ul><li><p>数组优化</p><p>  将<code>空数组[]</code>赋值给数组对象是清空数组的捷径，但是<code>空数组</code>也会占用内存。实际上<code>array.length = 0</code>也能清空数组，并且同时能实现数组重用，减少内存垃圾产生</p></li><li><p>对象尽量复用</p><p>  对象尽量复用，不用的对象尽可能设置为null，尽快被垃圾回收掉</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index Signature</title>
      <link href="/blog//Index-Signature/"/>
      <url>/blog//Index-Signature/</url>
      
        <content type="html"><![CDATA[<h2 id="Index-Signature"><a href="#Index-Signature" class="headerlink" title="Index Signature"></a><center>Index Signature</center></h2><h4 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h4><p>  你有两个对象，分别描述了两个工作人员的工资：<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> salary1 = &#123;</span><br><span class="line">  <span class="attr">baseSalary</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">yearlyBonus</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> salary2 = &#123;</span><br><span class="line">  <span class="attr">contractSalary</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  之后，你想实现一个函数，根据工作人员的工资信息得到总薪资</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">totalSalary</span>(<span class="params">salaryObject: ???</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> salaryObject) &#123;</span><br><span class="line">    total += salaryObject[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">totalSalary</span>(salary1); <span class="comment">// 30</span></span><br><span class="line"><span class="title function_">totalSalary</span>(salary2); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>  看起来函数似乎可以正常工作，<code>salaryObject</code>被<code>typescript</code>推断为any，这时候我们可以传入任何对象。当我们传入的对象值的类型不为<code>number</code>时，此函数将会在运行时报错（比如：<code>&#123; baseSalary: true &#125;</code>）</p><p>  这个时候应该如果定义<code>totalSalary</code>函数的参数<code>totalSalary</code>的类型注解呢？答案是<code>Index Signature</code>（索引签名），接下来我们来看看如何在<code>Typescript</code>中使用索引签名，以及何时需要它</p><h4 id="2-什么是索引签名？"><a href="#2-什么是索引签名？" class="headerlink" title="2. 什么是索引签名？"></a>2. 什么是索引签名？</h4><p>  当你不确定对象属性的名称，只知道属性和值的类型，这时可以使用索引签名来描述。</p><p>  比如<code>salaryObject</code>，我们可以确定属性的类型（<code>string</code>）、值的类型（<code>number</code>），但我们不知道具体的属性名。便可以使用索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> salaryType = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此类型描述了一个以字符串类型作为属性，数字类型作为值的对象。当我们传入非<code>number</code>类型的属性值对象时，<code>typescript</code>将会提示错误</p><h4 id="3-索引签名语法"><a href="#3-索引签名语法" class="headerlink" title="3. 索引签名语法"></a>3. 索引签名语法</h4><p>  索引签名语法非常简单，只需要在方括号内写下属性的类型：<code>&#123; [key: keyType]: valueType &#125;</code>，一些例子：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在第二个例子<code>Iss</code>中，我们还定义了一个<code>name</code>属性，标识此类型对象上必须要有一个<code>name</code>属性，但这里有一个限制，索引签名强制要求所有的属性值必须为索引签名的属性值相匹配（或子类型），否则，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  ~~name~~: <span class="built_in">boolean</span> <span class="comment">// Error: Property &#x27;name&#x27; of type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，索引签名属性只允许使用：string、number、symbol、template string（模板字符串）以及只包含这些类型的联合类型</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: ~~<span class="built_in">boolean</span>~~]: <span class="built_in">string</span> <span class="comment">// Error: An index signature parameter type must be &#x27;string&#x27;, &#x27;number&#x27;, &#x27;symbol&#x27;, or a template literal type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-索引签名注意事项"><a href="#4-索引签名注意事项" class="headerlink" title="4. 索引签名注意事项"></a>4. 索引签名注意事项</h4><ul><li><p>访问一个不存在的对象</p><p>当我们视图访问索引签名<code>&#123; [key: string]: string &#125;</code>对象上不存在的对象时，会发生什么？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>正如索引签名定义的那样，<code>Typescript</code>将会把<code>obj.a</code>推断为<code>string</code>，但我们知道，在运行时<code>obj.a</code>实际为<code>undefined</code></p><p>索引签名只会将属性类型映射到值类型，值类型可能会偏离实际允许时的数据，这部分需要根据实际代码自行处理。当然，你也可以将值类型增加<code>undefined</code>类型，这样<code>Typescript</code>会提示你访问的属性可能不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string | undefined</span></span><br></pre></td></tr></table></figure></li><li><p><code>string</code>和<code>number</code>类型属性</p><p>  当我们定义一个以数字为<code>key</code>的对象，我们可以直接定义为：<code>[key: string]: string</code>，如：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;one&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 obj[&#x27;1&#x27;] 或 obj[1] 访问</span></span><br><span class="line"><span class="keyword">const</span> val1 = obj[<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> val2 = obj[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>  为什么我们定义时<code>key</code>的类型为<code>string</code>，但确可以通过<code>number</code>访问，<code>Typescript</code>也不会提示错误呢？</p><p>  因为<code>JavaScript</code>在访问对象时，会隐式的将数字强制转换为字符串（<code>obj[1]</code>→ <code>obj[&#39;1&#39;]</code>），这意味着访问<code>obj[1]</code>和<code>obj[&#39;1&#39;]</code>是一样的，<code>Typescript</code>也执行这种隐式转换。因此我们可以同时定义两种类型的索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同样也要注意，数字类型属性值必须与字符串类型属性值的相匹配（或子类型）</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: ~~<span class="built_in">boolean</span>~~ <span class="comment">// Error: &#x27;number&#x27; index type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-索引签名与Record"><a href="#5-索引签名与Record" class="headerlink" title="5. 索引签名与Record"></a>5. 索引签名与Record</h4><p>  <code>Typescript</code>提供了一个实用类型<code>Record</code>：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>  它与索引签名类似，那么我们如何区分何时使用索引签名，何时使用<code>Record</code>呢？</p><p>  正如我们前面所提到的，索引签名对属性类型定义存在限制（索引签名属性类型只允许：string、number、symbol、template string）。当我们尝试在索引签名字面量类型或字面量联合类型，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [~~key~~: <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.</span></span><br></pre></td></tr></table></figure><p>  但我们可以通过<code>Record</code>定义：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Is</span> =  &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lemon&#x27;</span>,</span><br><span class="line">  <span class="attr">hobby</span>: <span class="string">&#x27;program&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以，建议使用索引签名来注释通用对象（当我们只知道属性的类型和属性值的类型时）。但当我们知道具体的属性时，建议使用<code>Record&lt;keys, Type&gt;</code>来注释特定对象</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li>索引签名的语法：<code>[key: KeyType]: ValueType</code>，其中<code>KeyType</code>类型只允许：<code>string、number、symbol、template string</code>，而<code>ValueType</code>可以是任何类型</li><li>当你不知道要注释的对象的具体结构（具体的属性名），但你知道属性名的类型和属性值的类型，那你可能需要的就是索引签名</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new.target</title>
      <link href="/blog//new-target/"/>
      <url>/blog//new-target/</url>
      
        <content type="html"><![CDATA[<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a><center>new.target</center></h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p><code>new.target</code>属性（ES6引入）允许你检测函数或构造方法是否通过<code>new</code>运算符进行调用。通过new运算符被初始化的函数或构造方法时，<code>new.target</code>返回一个指向构造方法或函数的引用，在普通的函数调用中，<code>new.target</code>返回<code>undefined</code></p></blockquote><p>  注意：</p><ul><li>在<code>arrow function</code>中，没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，<code>new.target</code>指向最近的外层函数的<code>new.target</code></li><li>在子类继承父类时，<code>new.target</code>指向初始化类的类定义，即子类</li></ul><h4 id="2-在ES5中如何限制函数通过new运算符调用"><a href="#2-在ES5中如何限制函数通过new运算符调用" class="headerlink" title="2. 在ES5中如何限制函数通过new运算符调用"></a>2. 在ES5中如何限制函数通过<code>new</code>运算符调用</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>this</code>将指向构造函数实例</p></li><li><p>普通调用函数，非严格模式<code>this</code>指向<code>window</code>，严格模式指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Window &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以通过判断<code>this</code>是否当前构造函数的实例，来判断是否通过<code>new</code>运算符调用，使用<code>this instanceof [构造函数]</code>，通过<code>new</code>调用返回<code>true</code>，普通调用返回<code>false</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 不建议使用 arguments.callee.name，在严格模式下arguments属性被移除</span></span><br><span class="line">  <span class="keyword">if</span>(!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Instance</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>()  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>但通过此方法判断并不完全准确，如果调用时通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向，将<code>this</code>指向构造函数实例，以上方法将无效</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()))  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-new-target"><a href="#3-new-target" class="headerlink" title="3. new.target"></a>3. new.target</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>new.target</code>指向构造方法或函数的引用</p></li><li><p>普通调用函数，<code>new.target</code>指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span>.<span class="property">target</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以使用<code>new.target</code>来限制构造函数必须通过<code>new</code>运算符调用</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变this指向</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>())) <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-使用new-target模拟实现抽象类"><a href="#4-使用new-target模拟实现抽象类" class="headerlink" title="4. 使用new.target模拟实现抽象类"></a>4. 使用<code>new.target</code>模拟实现抽象类</h4><ul><li><p>因为当子类继承父类时，<code>new.target</code>指向初始化类的类定义</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">P</span>() <span class="comment">// class P &#123; constructor() &#123; console.log(new.target) &#125; &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">S</span>() <span class="comment">// class S extends P &#123; constructor() &#123; super() &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>利用这一特性，可以模拟实现抽象类</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === P) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&#x27;Cannot create an instance of an abstract class.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">P</span>()) <span class="comment">// Uncaught SyntaxError: Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">S</span>()) <span class="comment">// S &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul><li>在ES5中，通过<code>new</code>运算符调用时<code>this</code>指向构造函数实例，普通调用时<code>this</code>在非严格模式指向<code>window</code>，严格模式指向<code>undefined</code>，利用这一特性，结合<code>this instanceof [构造函数]</code>，可以判断是否通过<code>new</code>运算符调用构造函数，但此方法并不安全，可以通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向</li><li>在ES6中，引入<code>new.target</code>属性，通过<code>new</code>运算符调用时<code>new.target</code>指向构造方法或函数的引用，普通调用函数，<code>new.target</code>指向<code>undefined</code>，可以通过此属性判断是否通过<code>new</code>运算符调用构造函数</li><li>利用<code>new.target</code>属性，可以模拟实现抽象类</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Preflight request</title>
      <link href="/blog//Preflight-request/"/>
      <url>/blog//Preflight-request/</url>
      
        <content type="html"><![CDATA[<h2 id="Preflight-request（预检请求）"><a href="#Preflight-request（预检请求）" class="headerlink" title="Preflight request（预检请求）"></a><center>Preflight request（预检请求）</center></h2><h4 id="1-什么是预检请求？"><a href="#1-什么是预检请求？" class="headerlink" title="1. 什么是预检请求？"></a>1. 什么是预检请求？</h4><blockquote><p>一个<code>CORS</code>预检请求是用于检查服务器是否支持<code>CORS</code>（跨域资源共享），由浏览器自动通过<code>OPTIONS</code>方法发起（<strong>非简单请求</strong>才会发起预检请求）。当预检请求完成，服务器确认允许后，才发起实际的HTTP请求。</p></blockquote><h4 id="2-简单请求与非简单请求"><a href="#2-简单请求与非简单请求" class="headerlink" title="2. 简单请求与非简单请求"></a>2. 简单请求与非简单请求</h4><ul><li><p>简单请求</p><ul><li>请求方法：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>请求首部字段只包含：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type<ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul></li></ul></li><li>如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器；也就是说，给定一个XMLHttpRequest实例xhr，没有调用xhr.upload.addEventListener()，以监听该上传请求</li><li>请求中没有使用ReadableStream对象</li></ul></li><li><p>非简单请求</p><ul><li>不满足简单请求的都是非简单请求</li></ul></li></ul><h4 id="3-预检请求中的请求首部字段"><a href="#3-预检请求中的请求首部字段" class="headerlink" title="3. 预检请求中的请求首部字段"></a>3. 预检请求中的请求首部字段</h4><ul><li>Origin：请求源URL（不包含路径）</li><li>Access-Control-Request-Method：实际请求所使用的HTTP方法</li><li>Access-Control-Request-Headers：实际请求时携带的自定义首部字段</li></ul><img src="/blog/Preflight-request/request-header.png" class="" title="Preflight request header"><h4 id="4-预见请求中的响应首部字段"><a href="#4-预见请求中的响应首部字段" class="headerlink" title="4. 预见请求中的响应首部字段"></a>4. 预见请求中的响应首部字段</h4><ul><li>Access-Control-Allow-Origin：允许该源访问资源地址，可以使用<code>*</code>通配符，表示任意源（仅当不需要携带<code>Cookie</code>时，如果携带<code>Cookie</code>，必须指定具体的源地址，否则将会请求失败）</li><li>Access-Control-Allow-Methods：允许使用的HTTP方法</li><li>Access-Control-Allow-Headers：允许使用的请求首部字段</li><li>Access-Control-Allow-Credentials：是否允许携带Cookie</li><li>Access-Control-Expose-Headers：<code>XMLHttpRequest</code>对象的 <code>getResponseHeader()</code>方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头</li><li>Access-Control-Max-Age：指定预检请求缓存时间，单位为秒，默认5秒</li></ul><img src="/blog/Preflight-request/response-header.png" class="" title="Preflight response header"><h4 id="5-完整请求流程图"><a href="#5-完整请求流程图" class="headerlink" title="5. 完整请求流程图"></a>5. 完整请求流程图</h4><img src="/blog/Preflight-request/request-flow.png" class="" title="request flow">]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用内置符号(well-known symbol)</title>
      <link href="/blog//%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7-well-known-symbol/"/>
      <url>/blog//%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7-well-known-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="常用内置符号-well-known-symbol"><a href="#常用内置符号-well-known-symbol" class="headerlink" title="常用内置符号(well-known symbol)"></a><center>常用内置符号(well-known symbol)</center></h2><p>  ES6引入了一批常用内置符合（well-known symbol）用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为</p><ul><li>内置符号以Symbol工厂函数字符串属性的形式存在</li><li>内置符号的主要用途之一是<strong>重新定义</strong>，从而改变原生结构的行为</li><li>内置符号没有特别之处，它们就是全局函数Symbol的普通字符串属性，指向一个符号的实例</li><li><strong>所有内置符号属性都是不可写（writeable: false），不可枚举（enumerable: false），不可配置（configurable: false）</strong></li></ul><p>  <strong>目前公有13个内置符号</strong></p><h4 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="Symbol.Iterator"></a><strong><code>Symbol.Iterator</code></strong></h4><p>  <code>Symbol.iterator</code>为每一个对象定义了默认的迭代器。</p><p>  示例：</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">idx</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> range = <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...range) <span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></code></pre><p>  一些拥有默认定义迭代器的内置类型：**<code>Array</code>、<code>TypedArray</code>、<code>String</code>、<code>Map</code>、<code>Set</code>**</p><h4 id="Symbol-asyncIterator"><a href="#Symbol-asyncIterator" class="headerlink" title="Symbol.asyncIterator"></a><strong><code>Symbol.asyncIterator</code></strong></h4><p>  <code>Symbol.asyncIterator</code>符号指定了一个对象的默认异步迭代器</p><p>  示例：</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">idx</span>++)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> r <span class="keyword">of</span> <span class="keyword">new</span> Range(<span class="number">5</span>)</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r) <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a><strong><code>Symbol.hasInstance</code></strong></h4><p>  <code>Symbol.hasInstance</code>用于判断某对象是否为某构造器的实例。因此你可以用它自定义 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a>操作符在某个类上的行为。</p><p>  ES6中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系，所以直接调用<code>Symbol.hasInstance</code>与使用<code>instanceof</code>操作符是一样的</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](a)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>  </code></pre><p>  <code>Symbol.hasInstance</code>属性定义在<code>Function</code>原型上，因此默认所有函数和类上都可以使用。也可以在类上<strong>通过静态方法重新定义</strong>这个函数</p><p>  <code>Symbol.hasInstance</code>返回一个<code>Boolean</code>, 如果返回的不是<code>Boolean</code>, 会将<code>Flasy</code>转换为<code>false</code>, 其余为<code>true</code></p><pre><code>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Surpass10</span> &#123;</span><br><span class="line">  <span class="comment">// 注意要使用静态方法，否则无法访问到此方法</span></span><br><span class="line">  <span class="comment">// Symbol.hasInstance返回一个Boolean, 如果返回的不是Boolean, 会将Flasy转换为false, 其余为true</span></span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](value) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(value) &amp;&amp; value &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span> <span class="keyword">instanceof</span> <span class="title class_">Surpass10</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span> <span class="keyword">instanceof</span> <span class="title class_">Surpass10</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><strong><code>Symbol.isConcatSpreadable</code></strong></h4><p>  <code>Symbol.isConcatSpreadable</code>符号用于配置某对象作为<code>Array.prototype.concat()</code>方法的参数时是否展开其数组元素</p><p>  数组默认<code>true</code>，类数组（<code>ArrayLike</code>）默认<code>false</code></p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">concat</span>(b)) <span class="comment">// [ 1, 2, 3, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">b[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">concat</span>(b)) <span class="comment">// [ 1, 2, 3, [ 3, 4, 5, [Symbol(Symbol.isConcatSpreadable)]: false ] ]</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a><strong><code>Symbol.match</code></strong></h4><p>  <code>Symbol.match</code>指定了匹配的是正则表达式而不是字符串。<code>String.prototype.match()</code>方法会调用此函数</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooMatcher</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123;</span><br><span class="line">    <span class="comment">// String.includes 用于查找字符串是否包含此字符串，返回布尔值</span></span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新定义Symbol.match() 函数 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringMatcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="variable language_">this</span>.<span class="property">str</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个String为总字符串，第二个String为要查找的字符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-matchAll"><a href="#Symbol-matchAll" class="headerlink" title="Symbol.matchAll"></a><strong><code>Symbol.matchAll</code></strong></h4><p>  <code>String.prototype.matchAll()</code>方法会调用此函数</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;2016-01-02|2019-03-07&quot;</span></span><br><span class="line"><span class="keyword">const</span> numbers = &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">matchAll</span>](str) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> str.<span class="title function_">matchAll</span>(<span class="regexp">/[0-9]+/g</span>)) <span class="keyword">yield</span> n[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(str.<span class="title function_">matchAll</span>(numbers))) <span class="comment">// [ &#x27;2016&#x27;, &#x27;01&#x27;, &#x27;02&#x27;, &#x27;2019&#x27;, &#x27;03&#x27;, &#x27;07&#x27; ]</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a><strong><code>Symbol.replace</code></strong></h4><p>  <code>Symbol.replace</code>这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。<code>String.prototype.replace()</code>方法会调用此方法</p><p>  <code>Symbol.replace</code>接收两个参数，调用 replace()方法的字符串实例和替换字符串</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Replace1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="built_in">string</span>, replace) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`s/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/<span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span>/<span class="subst">$&#123;replace&#125;</span>/g`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">Replace1</span>(<span class="string">&#x27;bar&#x27;</span>), <span class="string">&#x27;zoo&#x27;</span>)) <span class="comment">// s/foo/bar/zoo/g</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a><strong><code>Symbol.search</code></strong></h4><p>  <code>Symbol.search</code> 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 <code>String.prototype.search()</code></p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">caseInsensitiveSearch</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">search</span>](<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title function_">caseInsensitiveSearch</span>(<span class="string">&#x27;BaR&#x27;</span>))) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a><strong><code>Symbol.species</code></strong></h4><p>  <code>Symbol.species</code> 符号属性表示“一个函数值，该函数作为创建派生对象的构造函数”；这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="comment">// 覆盖 species 到父级的 Array 构造函数上</span></span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> mapped = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">MyArray</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapped <span class="keyword">instanceof</span> <span class="title class_">Array</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a><strong><code>Symbol.split</code></strong></h4><p>  <code>Symbol.split</code>指向 一个正则表达式的索引处分割字符串的方法。这个方法通过 <code>String.prototype.split()</code>调用</p><p>  <code>Symbol.split</code>函数接收一个参数，调用<code>match()</code>方法的字符串实例</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Split1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">split</span>](<span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">string</span>.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>.substr(<span class="number">0</span>, index)&#125;</span>/<span class="subst">$&#123;<span class="built_in">string</span>.substr(index + <span class="variable language_">this</span>.value.length)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">Split1</span>(<span class="string">&#x27;foo&#x27;</span>)))</span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><strong><code>Symbol.toPrimitive</code></strong></h4><p>  <code>Symbol.toPrimitive</code>是内置的 symbol 属性，其指定了一种接受首选类型并返回对象原始值的表示的方法。它被所有的强类型转换制算法优先调用</p><p>  在 <code>Symbol.toPrimitive</code>属性（用作函数值）的帮助下，对象可以转换为一个原始值。该函数被调用时，会被传递一个字符串参数 <code>hint</code>，表示要转换到的原始值的预期类型。<code>hint</code>参数的取值是 <code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>和 <code>&quot;default&quot;</code>中的任意一个</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj) <span class="comment">// 10  — hint 参数值是 &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>) <span class="comment">// &quot;hello&quot;   — hint 参数值是 &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;true&quot;    — hint 参数值是 &quot;default&quot;</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a><strong><code>Symbol.toStringTag</code></strong></h4><p>  <code>Symbol.toStringTag</code>用于创建对象的默认字符串描述。它由 <code>Object.prototype.toString()</code>方法内部访问</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidatorClass</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Validator&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">ValidatorClass</span>())) <span class="comment">// &#x27;[object Validator]&#x27;</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a><strong><code>Symbol.unscopables</code></strong></h4><p>  <code>Symbol.unscopables</code>指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称</p><pre><code><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">property1</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">property2</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object1[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123;</span><br><span class="line">  <span class="attr">property2</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (object1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(property1) <span class="comment">// 42</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(property2) <span class="comment">// Expected output: Error: property1 is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol</title>
      <link href="/blog//Symbol/"/>
      <url>/blog//Symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><center>Symbol</center></h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>  ES6引入了一种新的原始数据类型<code>symbol</code>，表示独一无二的值。它属于JavaScript语言的数据类型之一</p><p>  八大数据类型：<code>Symbol、undefined、null、Boolean、String、Number、Bigint、Object</code></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不要使用new命令，由于Symbol值不是对象，所以不能添加属性</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol值不能与其他类型的值进行预算，会报错</span></span><br><span class="line"></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;s&#125;</span>`</span> <span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是Symbol值可以显示转为字符串</span></span><br><span class="line"><span class="title class_">String</span>(s) <span class="comment">// &#x27;Symbol(feature)&#x27;</span></span><br><span class="line">s.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(feature)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以转为布尔值</span></span><br><span class="line"><span class="title class_">Boolean</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-作为属性名的Symbol"><a href="#2-作为属性名的Symbol" class="headerlink" title="2. 作为属性名的Symbol"></a>2. 作为属性名的<code>Symbol</code></h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[symbol] = <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [symbol]: <span class="string">&#x27;hello!&#x27;</span>  <span class="comment">// 方括号为ES6计算属性（computedPropertyName）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, symbol, &#123;&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>()</span><br></pre></td></tr></table></figure><p>  注意：<code>Symbol</code> 值作为对象属性名时，不能用点运算符（ES6的动态属性只在方括号中生效，而点<code>.</code>运算符后面总是字符串）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sy]: <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">sy</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[sy]) <span class="comment">// &#x27;feature&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-遍历属性名"><a href="#3-遍历属性名" class="headerlink" title="3. 遍历属性名"></a>3. 遍历属性名</h4><p>  <code>Symbol</code> 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>()</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>() <span class="comment">//Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名</span></span><br></pre></td></tr></table></figure><h4 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h4><ul><li><p><code>Symbol.prototype.description</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Symbol对象的描述</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;feature&#x27;</span>)</span><br><span class="line">s.<span class="property">descriotion</span> <span class="comment">// &quot;feature&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.for()</code>：注意会被登记到全局环境，可以在不同的 <code>iframe</code> 或 <code>service worker</code> 中取到同一个值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p> 注意：</p><ul><li><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code></li><li><code>Symbol.for()</code>会被登记到全局环境，<code>Symbol()</code>不会</li><li><code>Symbol.for()</code>会先检查给定的<code>key</code>是否已经存在,如果不存在则创建一个新的<code>Symbol</code>，存在就返回这个<code>Symbol</code>值</li></ul></li><li><p><code>Symbol.keyFor()</code>：返回被<code>Symbol.for()</code>注册到全局<code>Symbol</code>类型值的<code>key</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;feature&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1) <span class="comment">// &quot;feature&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;feature&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-常用实例"><a href="#5-常用实例" class="headerlink" title="5. 常用实例"></a>5. 常用实例</h4><ul><li><p>消除魔术字符串：魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;circle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见解决方法：使用变量</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">circle</span>: <span class="string">&#x27;circle&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.<span class="property">circle</span>: <span class="comment">// 使用变量</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Symbol，定义的变量的属性值并不重要，只是为了区分</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">circle</span>: <span class="title class_">Symbol</span>() <span class="comment">// 使用Symbol</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript函数式编程初体验</title>
      <link href="/blog//TypeScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/blog//TypeScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript函数式编程初体验"><a href="#TypeScript函数式编程初体验" class="headerlink" title="TypeScript函数式编程初体验"></a><center>TypeScript函数式编程初体验</center></h2><p>函数式编程是一种编写代码的方法，它将计算视为函数的执行，并避免使用可变状态和副作用。这种方法可以使代码更加简单、易于测试和可组合。而TypeScript作为一种类型安全的JavaScript超集，非常适合用于函数式编程。</p><p>在本篇博客中，我们将探讨一些常见的函数式编程概念，并展示如何在TypeScript中使用它们来编写更加可组合和类型安全的代码。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是函数式编程中的一种重要概念。它们是将函数作为参数或返回值的函数，可以使代码更加可组合和灵活。</p><p>在TypeScript中，我们可以使用函数类型来定义高阶函数。例如，以下函数接受一个函数参数和一个数字参数，并返回一个函数，该函数将给定的函数重复执行指定的次数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span></span><br><span class="line"><span class="params">  fn: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  times: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = x</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">      result = <span class="title function_">fn</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了箭头函数语法来定义函数类型 <code>(x: number) =&gt; number</code>，它表示接受一个数字参数并返回一个数字。</p><p>接着，我们定义了一个 <code>repeat</code> 函数，它接受一个函数参数 <code>fn</code> 和一个数字参数 <code>times</code>。该函数返回一个函数，该函数接受一个数字参数 <code>x</code>，并重复执行 <code>fn</code> 函数 <code>times</code> 次。</p><p>例如，我们可以使用以下代码来定义一个将数字乘以2的函数，并将其传递给 <code>repeat</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> repeatedDouble = <span class="title function_">repeat</span>(double, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">repeatedDouble</span>(<span class="number">2</span>)); <span class="comment">// 输出 16（2 * 2 * 2）</span></span><br></pre></td></tr></table></figure><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数是一种没有副作用并且输入相同会始终返回相同结果的函数。这种函数是函数式编程中的核心概念，可以使代码更加可预测和易于测试。</p><p>在TypeScript中，我们可以使用类型来强制实现纯函数。例如，以下函数接受一个数字参数，并返回该数字的平方：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>square</code> 接受一个数字参数 <code>x</code>，并返回它的平方。因为这个函数没有任何副作用，并且对于相同的输入始终返回相同的结果，所以它是一个纯函数。</p><p>然而，如果我们在函数内部修改外部状态或调用具有副作用的函数，则函数就不再是纯函数。例如，以下函数接受一个数组参数，并在其中添加一个新元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addItem</span>(<span class="params">arr: <span class="built_in">any</span>[], item: <span class="built_in">any</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>addItem</code> 对外部状态（即数组 <code>arr</code>）进行了修改，并且没有返回任何值，因此它不是纯函数。</p><h3 id="不可变数据"><a href="#不可变数据" class="headerlink" title="不可变数据"></a>不可变数据</h3><p>不可变数据是指在程序执行过程中不会发生变化的数据。在函数式编程中，不可变数据非常重要，因为它可以确保代码更加可预测和易于测试。</p><p>在TypeScript中，我们可以使用 <code>readonly</code> 关键字来定义不可变数据。例如，以下代码定义了一个只读的数组变量 <code>numbers</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">numbers</span>: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>readonly</code> 关键字来定义了一个只读的数组变量 <code>numbers</code>，它包含三个数字元素。因为 <code>numbers</code> 是只读的，所以我们不能对其进行任何修改操作。</p><p>如果我们需要对数组进行修改操作，则可以使用 <code>slice</code> 或 <code>concat</code> 等函数来创建一个新的数组。例如，以下代码使用 <code>slice</code> 函数来从数组中删除第一个元素，并返回一个新的数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newNumbers = numbers.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNumbers) <span class="comment">// 输出 [2, 3]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>slice</code> 函数来创建了一个新的数组 <code>newNumbers</code>，它包含了 <code>numbers</code> 数组中的后两个元素。因为我们没有修改原始的 <code>numbers</code> 数组，所以它仍然是不可变的。</p><h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>函数组合是一种将多个函数组合成一个新函数的方法。这种方法可以使代码更加可读和可组合。</p><p>在TypeScript中，我们可以使用函数类型来定义函数组合。例如，以下代码定义了两个函数 <code>double</code> 和 <code>square</code>，并将它们组合成一个新的函数 <code>doubleSquare</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; x * <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; x * x</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doubleSquare</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; <span class="title function_">square</span>(<span class="title function_">double</span>(x))</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>double</code> 和 <code>square</code> 分别表示将数字乘以2和将数字平方的函数。我们然后定义了一个新的函数 <code>doubleSquare</code>，它将数字先乘以2，然后再将结果平方。</p><p>可以看出，函数组合可以使代码更加可读和易于理解。如果我们需要在两个函数之间进行组合操作，只需要将它们作为参数传递给一个新的函数即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addOne</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiplyTwo</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; x * <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOneThenMultiplyTwo</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; <span class="title function_">multiplyTwo</span>(<span class="title function_">addOne</span>(x))</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个函数 <code>addOne</code> 和 <code>multiplyTwo</code>，分别表示将数字加1和将数字乘以2的函数。然后我们定义了一个新的函数 <code>addOneThenMultiplyTwo</code>，它将数字先加1，然后再乘以2。</p><p>在实际应用中，函数组合可以使代码更加简洁和易于维护。例如，在编写一些数据处理代码时，我们通常需要将多个数据转换函数组合在一起，以便将数据从一种形式转换为另一种形式。</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化是一种将多个参数的函数转换为一系列单参数函数的方法。这种方法可以使函数组合更加容易和灵活。</p><p>在TypeScript中，我们可以使用柯里化来将多参数函数转换为单参数函数。例如，以下代码定义了一个接受两个数字参数的函数 <code>add</code>，并将其转换为一个接受一个数字参数的函数 <code>curriedAdd</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; x + y</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curriedAdd</span> = (<span class="params">x: <span class="built_in">number</span></span>) =&gt; <span class="function">(<span class="params">y: <span class="built_in">number</span></span>) =&gt;</span> <span class="title function_">add</span>(x, y)</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>add</code> 接受两个数字参数并返回它们的和。然后我们使用柯里化来将函数 <code>add</code> 转换为一个接受一个数字参数的函数 <code>curriedAdd</code>。我们可以通过调用 <code>curriedAdd</code> 函数来创建一个新的函数，该函数接受一个数字参数 <code>x</code> 并返回一个新函数，该函数接受另一个数字参数 <code>y</code> 并返回它们的和。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addOne = <span class="title function_">curriedAdd</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addOne</span>(<span class="number">2</span>)) <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先调用 <code>curriedAdd(1)</code> 来创建一个新的函数 <code>addOne</code>，该函数接受一个数字参数 <code>y</code> 并返回 <code>1 + y</code> 的结果。然后我们调用 <code>addOne(2)</code> 来计算 <code>1 + 2</code> 的结果，并输出结果 <code>3</code>。</p><p>柯里化可以使函数组合更加容易和灵活。例如，在编写一些高阶函数时，我们通常需要将多参数函数转换为单参数函数，以便更好地与其他函数进行组合。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归是一种在函数最后一步调用自身的递归方式。这种递归方式可以使递归调用更加高效，并且可以避免栈溢出的问题。</p><p>在TypeScript中，我们可以使用尾递归来优化递归调用。例如，以下代码定义了一个递归函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">factorial</span> = (<span class="params">n: <span class="built_in">number</span>, acc = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, acc * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>factorial</code> 是一个递归函数，用于计算给定数字的阶乘。它使用尾递归来避免栈溢出的问题。函数 <code>factorial</code> 接受两个参数，一个表示要计算阶乘的数字 <code>n</code>，另一个表示计算结果的累积器 <code>acc</code>，默认值为 <code>1</code>。在函数的主体中，我们使用条件语句来检查是否已经计算到了 <code>0</code> 的阶乘。如果是，则返回累积器的值。否则，我们调用 <code>factorial</code> 函数并传入新的参数 <code>n-1</code> 和 <code>acc*n</code>。</p><p>使用尾递归可以避免栈溢出的问题，并使递归调用更加高效。在实际应用中，我们可以使用尾递归来优化一些需要递归的算法和函数。</p><h3 id="高阶函数-1"><a href="#高阶函数-1" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是指可以接受一个或多个函数作为参数，并&#x2F;或者返回一个函数作为结果的函数。在TypeScript中，高阶函数可以帮助我们实现更加灵活和可复用的代码。</p><p>例如，以下代码定义了一个高阶函数 <code>map</code>，用于将一个数组中的每个元素映射到一个新的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = &lt;T, U&gt;<span class="function">(<span class="params">f: (x: T) =&gt; U</span>) =&gt;</span> (<span class="attr">xs</span>: T[]): U[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: U[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> xs) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(<span class="title function_">f</span>(x))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>map</code> 接受一个函数 <code>f</code>，该函数接受一个类型为 <code>T</code> 的参数并返回一个类型为 <code>U</code> 的结果。然后，我们使用一个箭头函数来返回一个新函数，该函数接受一个类型为 <code>T[]</code> 的数组并将其映射到一个类型为 <code>U[]</code> 的结果数组。在函数的主体中，我们遍历输入数组，并使用函数 <code>f</code> 来计算每个元素的新值，并将这些新值添加到结果数组中。最后，我们返回结果数组。</p><p>使用高阶函数可以使代码更加灵活和可复用。例如，在编写一些数据处理代码时，我们可以使用高阶函数来将多个数据转换函数组合在一起，并将它们应用到输入数据中。这种方法可以使代码更加简洁和易于维护。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们介绍了一些JavaScript&#x2F;TypeScript中的函数式编程技术，包括纯函数、不可变性、函数组合、柯里化、尾递归和高阶函数。这些技术可以帮助我们编写更加灵活、可复用的代码，并减少出错的机会。虽然这些技术可能需要一些时间来适应，但它们可以使代码更加可读、可维护和易于测试。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESModule与CommonJS模块化规范</title>
      <link href="/blog//ESModule%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <url>/blog//ESModule%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="ESModule与CommonJS模块化规范"><a href="#ESModule与CommonJS模块化规范" class="headerlink" title="ESModule与CommonJS模块化规范"></a><center>ESModule与CommonJS模块化规范</center></h2><p>JavaScript 的模块化一直是一个比较棘手的问题。在 ES6 之前，JavaScript 没有内置的模块化机制，这导致了开发者需要使用一些其他的方式来管理代码的依赖关系，例如使用 IIFE（立即执行函数）等方式来实现模块化编程。这些方式虽然可以实现代码的模块化，但是代码的可读性和可维护性并不是很好。</p><p>在 ES6 中，JavaScript 引入了模块化规范，这使得我们可以更加方便地管理代码的依赖关系，提高代码的可重用性和可维护性。ES6 引入了一种新的模块化规范，即 ESModule（ES6 Module），与之前的 CommonJS 模块化规范有一些区别。</p><h3 id="ESModule-模块化规范"><a href="#ESModule-模块化规范" class="headerlink" title="ESModule 模块化规范"></a>ESModule 模块化规范</h3><p>ESModule 是 ES6 中引入的一种模块化规范，它的设计目标是实现一个先进的、可靠的、可静态分析的模块化系统，以适应 JavaScript 在大型项目中的复杂性。</p><h4 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h4><p>ESModule 中使用 <code>import</code> 和 <code>export</code> 关键字来进行导入和导出。导入和导出的语法非常简洁明了，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ESModule 中，每个模块都是一个独立的文件，每个文件中可以有多个导入和导出。使用 ESModule 进行模块化编程可以使得代码的可读性和可维护性大大提高，同时也可以提高代码的重用性。</p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>ESModule 中的导入和导出是静态分析的，这意味着它可以在编译时分析依赖关系，从而进行一些优化。例如，可以将导入的模块转换为常量，从而提高代码的执行效率。</p><h4 id="顶级作用域"><a href="#顶级作用域" class="headerlink" title="顶级作用域"></a>顶级作用域</h4><p>ESModule 中的每个模块都具有自己的顶级作用域，这意味着每个模块中的变量和函数都不会污染全局命名空间。这可以使得代码的可读性和可维护性大大提高，同时也可以避免命名冲突等问题。</p><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><p>CommonJS 是一种比较成熟的 JavaScript 模块化规范，它最初是为 Node.js 设计的，但是现在也可以在浏览器中使用。CommonJS 中使用 <code>require</code> 和 <code>module.exports</code> 关键字来进行导入和导出。与 ESModule 不同的是，CommonJS 中的导入和导出是动态的，这意味着它是在运行时解析的，而不是在编译时解析的。</p><h4 id="导入和导出-1"><a href="#导入和导出-1" class="headerlink" title="导入和导出"></a>导入和导出</h4><p>CommonJS 中使用 <code>require</code> 函数来导入模块，使用 <code>module.exports</code> 对象来导出模块。导入和导出的语法相对 ESModule 来说较为繁琐，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">const</span> &#123; add &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CommonJS 中，每个模块也是一个独立的文件，每个文件中可以有多个导入和导出。与 ESModule 不同的是，CommonJS 中的导入和导出是动态的，这意味着在运行时需要对每个模块进行解析，这会导致一些性能问题。</p><h4 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h4><p>由于 CommonJS 中的导入和导出是动态的，所以它具有一些动态特性，例如可以在运行时动态加载模块。这些特性在某些场景下是非常有用的，但是在一些其他场景下也可能会导致一些问题，例如因为动态特性导致代码无法进行静态分析，从而无法进行优化。</p><h3 id="ESModule-与-CommonJS-的区别"><a href="#ESModule-与-CommonJS-的区别" class="headerlink" title="ESModule 与 CommonJS 的区别"></a>ESModule 与 CommonJS 的区别</h3><p>虽然 ESModule 和 CommonJS 都是 JavaScript 的模块化规范，但是它们之间存在一些区别，主要包括以下几个方面：</p><h4 id="导入和导出的语法"><a href="#导入和导出的语法" class="headerlink" title="导入和导出的语法"></a>导入和导出的语法</h4><p>ESModule 使用 <code>import</code> 和 <code>export</code> 关键字来进行导入和导出，而 CommonJS 使用 <code>require</code> 和 <code>module.exports</code> 关键字来进行导入和导出。ESModule 的语法相对简洁明了，而 CommonJS 的语法相对较为繁琐。</p><h4 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h4><p>ESModule 中的导入和导出是静态分析的，可以在编译时分析依赖关系，并进行一些优化。而 CommonJS 中的导入和导出是动态的，需要在运行时进行解析。这导致 ESModule 具有更好的性能和可维护性。</p><h4 id="顶级作用域-1"><a href="#顶级作用域-1" class="headerlink" title="顶级作用域"></a>顶级作用域</h4><p>ESModule 中的每个模块都具有自己的顶级作用域，而 CommonJS 中的模块共享全局作用域。这意味着 ESModule 中的变量和函数不会污染全局命名空间，而 CommonJS 中可能会存在命名冲突等问题。</p><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>ESModule 中不允许循环依赖，如果出现循环依赖会报错。而 CommonJS 中可以处理循环依赖，但是会存在一些问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ESModule 和CommonJS 都是 JavaScript 的模块化规范，它们都具有各自的优缺点和适用场景。ESModule 具有更好的性能和可维护性，适用于需要大规模管理的项目和需要进行静态分析的场景；而 CommonJS 具有动态特性，适用于需要动态加载模块的场景。</p><p>在实际开发中，我们可以根据具体的情况选择不同的模块化方案。如果我们正在开发一个 Node.js 项目，可以使用 CommonJS 规范来进行模块化；如果我们正在开发一个大规模的 Web 应用，可以使用 ESModule 规范来进行模块化。</p><p>总的来说，模块化是现代化 JavaScript 开发的重要组成部分，它可以提高代码的可维护性、可重用性和可扩展性，使得 JavaScript 应用程序更加易于开发和维护。无论是 ESModule 还是 CommonJS，它们都是非常重要的 JavaScript 模块化规范，值得我们深入了解和学习。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/blog//JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/blog//JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript异步编程"><a href="#JavaScript异步编程" class="headerlink" title="JavaScript异步编程"></a><center>JavaScript异步编程</center></h2><p>JavaScript是一种单线程的编程语言，这意味着它一次只能处理一个任务。在某些情况下，这可能会导致JavaScript的性能和响应能力下降，因为某些操作可能需要花费很长时间，这将阻止JavaScript继续执行其他任务</p><p>为了解决这个问题，JavaScript引入了异步编程，这是一种处理长时间运行任务的方法，可以在执行其他任务时执行异步任务。异步编程在Web应用程序开发中扮演着重要的角色，因为Web应用程序经常需要与远程服务器通信、处理用户输入和响应用户操作</p><p>在本文中，我们将深入了解JavaScript异步编程的基本概念、异步编程的原理和回调函数、Promise、async&#x2F;await等异步编程技术，以及如何使用这些技术处理异步任务。我们还将讨论一些实际的案例，以帮助你更好地理解和应用异步编程</p><h2 id="异步编程的基本概念"><a href="#异步编程的基本概念" class="headerlink" title="异步编程的基本概念"></a>异步编程的基本概念</h2><p>异步编程是一种处理长时间运行任务的方法，可以在执行其他任务时执行异步任务。异步编程是非阻塞的，这意味着代码不会停止等待异步任务完成，而是继续执行其他任务，当异步任务完成后，它将通过回调函数通知程序</p><p>JavaScript的异步编程主要依赖于两个基本概念：事件循环和回调函数</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环是JavaScript的核心概念之一，它负责管理JavaScript执行的顺序。事件循环会不断地从事件队列中获取事件，并将它们分配给JavaScript引擎执行。事件循环是单线程的，这意味着它一次只能处理一个任务。因此，如果一个任务需要花费很长时间，它将阻止其他任务的执行，从而导致JavaScript的性能和响应能力下降</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是JavaScript异步编程的核心概念之一，它是一种在异步任务完成后调用的函数。当一个异步任务完成时，它将调用一个回调函数，并将异步任务的结果作为参数传递给它。回调函数可以用于处理异步任务的结果，并采取适当的措施</p><h2 id="回调函数的原理"><a href="#回调函数的原理" class="headerlink" title="回调函数的原理"></a>回调函数的原理</h2><p>回调函数是JavaScript异步编程的基础，回调函数可以用于处理异步任务的结果，并采取适当的措施，例如更新UI、处理数据等</p><p>下面是一个简单的例子，演示了如何使用回调函数处理异步任务的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAsyncTask</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doAsyncTask</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>doAsyncTask</code>函数是一个异步任务，它将在1秒后返回结果。当异步任务完成时，它将调用回调函数，并将结果作为参数传递给它。在这个例子中，回调函数将结果打印到控制台</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数是JavaScript异步编程的基础，但它们也会导致一些问题，例如回调地狱（Callback Hell）和可读性差。为了解决这些问题，ES6引入了Promise，它是一种更高级的异步编程技术</p><p>Promise是一个包装异步操作结果的对象，可以用于处理异步任务的结果，并提供一组可组合的操作符。Promise对象有三种状态：Pending（等待）、Resolved（已解决）和Rejected（已拒绝）。</p><p>当一个异步任务开始执行时，它将返回一个Promise对象，并进入Pending状态。当异步任务完成时，它将调用resolve函数或reject函数，使Promise对象进入Resolved状态或Rejected状态。</p><p>以下是一个使用Promise的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAsyncTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doAsyncTask</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>doAsyncTask</code>函数返回一个Promise对象，并在1秒后调用resolve函数。在调用resolve函数时，Promise对象将进入Resolved状态，并将结果作为参数传递给then函数。如果在执行异步任务时发生错误，Promise对象将调用reject函数，进入Rejected状态，并将错误作为参数传递给catch函数。</p><p>使用Promise可以避免回调地狱和提高代码可读性。Promise还提供了一组可组合的操作符，例如<code>then</code>、<code>catch</code>、<code>finally</code>、<code>race</code>和<code>all</code>，可以用于处理异步任务的结果，并支持链式调用</p><h2 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>async&#x2F;await是ES2017引入的另一种异步编程技术，它是基于Promise的语法糖。使用async&#x2F;await可以将异步任务看作同步任务，使代码更容易编写和阅读</p><p>在使用async&#x2F;await时，我们需要将异步函数定义为async函数，并在调用异步函数时使用await关键字等待异步任务完成。以下是一个使用async&#x2F;await的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAsyncTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doAsyncTask</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncExample</span>()</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>asyncExample</code>函数定义为async函数，它使用await关键字等待异步任务完成。如果异步任务成功完成，它将返回结果，并将结果赋值给result变量。如果异步任务失败，它将抛出一个错误，并将错误捕获到catch块中</p><p>使用async&#x2F;await可以使异步代码看起来像同步代码，使代码更容易编写和阅读。但需要注意的是，async&#x2F;await本质上还是基于Promise的，所以它们具有相同的限制和局限性。例如，它们不能用于处理多个异步任务并行执行的情况</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator是另一种异步编程技术，它可以使异步代码看起来更像同步代码，但与async&#x2F;await不同的是，它可以在代码执行期间暂停和恢复执行</p><p>在使用Generator时，我们需要定义一个Generator函数，并在其中使用yield关键字暂停执行。Generator函数将返回一个Generator对象，它可以用于控制执行流程，并在需要时暂停和恢复执行。以下是一个使用Generator的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="title function_">doAsyncTask1</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="title function_">doAsyncTask2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doAsyncTask1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doAsyncTask2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">genExample</span>()</span><br><span class="line"><span class="keyword">const</span> promise1 = gen.<span class="title function_">next</span>().<span class="property">value</span></span><br><span class="line"></span><br><span class="line">promise1.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise2 = gen.<span class="title function_">next</span>(result1).<span class="property">value</span></span><br><span class="line">  promise2.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result2</span>) &#123;</span><br><span class="line">    gen.<span class="title function_">next</span>(result2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>genExample</code>函数定义为Generator函数，它使用yield关键字暂停执行，并在需要时恢复执行。在执行Generator函数时，我们需要调用next方法，以启动执行流程，并传递上一次yield操作的结果。当执行流程暂停时，next方法将返回一个Promise对象，该对象表示异步任务的结果。在异步任务完成后，我们需要使用then方法获取结果，并调用next方法，以恢复执行流程</p><p>Generator虽然可以使异步代码看起来更像同步代码，但它的使用方式比较复杂，并且需要手动控制执行流程。在实际开发中，建议使用async&#x2F;await或Promise，以便更容易地处理异步任务。但是，了解Generator也是很有用的，它可以帮助我们理解异步编程的工作原理</p><h2 id="异步编程实践"><a href="#异步编程实践" class="headerlink" title="异步编程实践"></a>异步编程实践</h2><p>异步编程在实际开发中非常常见，我们经常需要处理异步任务，例如从服务器获取数据、处理用户输入等。在本节中，我们将介绍一些常见的异步编程实践</p><h3 id="处理多个异步任务"><a href="#处理多个异步任务" class="headerlink" title="处理多个异步任务"></a>处理多个异步任务</h3><p>在实际开发中，我们经常需要处理多个异步任务，例如从多个服务器获取数据、同时处理多个用户输入等。在处理多个异步任务时，我们可以使用Promise.all方法，它可以等待多个异步任务全部完成，并将它们的结果作为一个数组返回。以下是一个使用Promise.all的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">doAsyncTask1</span>(),</span><br><span class="line">  <span class="title function_">doAsyncTask2</span>(),</span><br><span class="line">  <span class="title function_">doAsyncTask3</span>(),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将多个异步任务的Promise对象放在一个数组中，并将该数组作为参数传递给Promise.all方法。当所有异步任务完成时，Promise.all将返回一个数组，该数组包含所有异步任务的结果。如果任何一个异步任务失败，Promise.all将抛出一个错误</p><h3 id="处理并发异步任务"><a href="#处理并发异步任务" class="headerlink" title="处理并发异步任务"></a>处理并发异步任务</h3><p>在处理并发异步任务时，我们需要确保它们同时执行，并在所有任务完成后返回结果。在这种情况下，我们可以使用Promise.race方法，它可以等待多个异步任务中的任何一个完成，并将其结果作为一个单独的值返回。以下是一个使用Promise.race的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">doAsyncTask1</span>(),</span><br><span class="line">  <span class="title function_">doAsyncTask2</span>(),</span><br><span class="line">  <span class="title function_">doAsyncTask3</span>(),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将多个异步任务的Promise对象放在一个数组中，并将该数组作为参数传递给Promise.race方法。当任何一个异步任务完成时，Promise.race将返回该任务的结果，并立即终止所有其他任务。如果任何一个异步任务失败，Promise.race将抛出一个错误</p><h3 id="处理异步任务序列"><a href="#处理异步任务序列" class="headerlink" title="处理异步任务序列"></a>处理异步任务序列</h3><p>在处理异步任务序列时，我们需要确保它们按顺序执行，并在上一个任务完成后再执行下一个任务。在这种情况下，我们可以使用async&#x2F;await或Generator，以便更容易地控制执行流程。以下是一个使用async&#x2F;await的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sequenceExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="title function_">doAsyncTask1</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">doAsyncTask2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">  <span class="keyword">const</span> result3 = <span class="keyword">await</span> <span class="title function_">doAsyncTask3</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sequenceExample</span>()</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个async函数，它使用await关键字等待异步任务完成，并按顺序执行异步任务。如果任何一个异步任务失败，async函数将抛出一个错误</p><h3 id="处理异步任务流"><a href="#处理异步任务流" class="headerlink" title="处理异步任务流"></a>处理异步任务流</h3><p>在处理异步任务流时，我们需要确保它们能够动态地流式处理，并在需要时停止或重试任务。在这种情况下，我们可以使用流式编程库，例如RxJS或Bacon.js，以便更容易地处理异步任务流。以下是一个使用RxJS的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interval &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; take, map &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="title function_">interval</span>(<span class="number">1000</span>).<span class="title function_">pipe</span>(<span class="title function_">take</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">const</span> example = source.<span class="title function_">pipe</span>(<span class="title function_">map</span>(<span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span>))</span><br><span class="line">example.<span class="title function_">subscribe</span>(</span><br><span class="line">  <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value),</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error),</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Completed!&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="处理回调地狱"><a href="#处理回调地狱" class="headerlink" title="处理回调地狱"></a>处理回调地狱</h3><p>在JavaScript中，回调地狱是一个常见的问题，特别是在处理多个异步任务时。在回调地狱中，我们需要嵌套多个回调函数，以便在异步任务完成后执行其他任务。这很容易导致代码混乱和难以维护。以下是一个回调地狱的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doAsyncTask1</span>(<span class="keyword">function</span>(<span class="params">result1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line">  <span class="title function_">doAsyncTask2</span>(<span class="keyword">function</span>(<span class="params">result2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">    <span class="title function_">doAsyncTask3</span>(<span class="keyword">function</span>(<span class="params">result3</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(result3)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们需要嵌套3个回调函数，以便在异步任务完成后执行其他任务。这使得代码难以阅读和维护</p><p>为了解决这个问题，我们可以使用Promise、async&#x2F;await或流式编程库，以便更容易地处理多个异步任务。这些方法使得代码更加清晰和易于维护。以下是一个使用Promise的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doAsyncTask1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncTask2</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncTask3</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result3</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result3)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用Promise链，以便按顺序执行多个异步任务。每个Promise在前一个Promise完成后开始执行，并且可以使用then方法处理成功的结果或catch方法处理错误的结果。这使得代码更加清晰和易于维护</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在JavaScript中，异步编程是必不可少的。JavaScript提供了多种方式来处理异步操作，例如回调函数、Promise、async&#x2F;await和生成器函数。回调函数是最基本的异步编程方式，但它存在回调地狱和错误处理的问题。Promise是一个表示异步操作的对象，它可以避免回调地狱和提供更好的错误处理。async&#x2F;await是一种让异步代码看起来像同步代码的语法糖，它可以更轻松地处理异步操作。生成器函数是一种特殊的函数，它可以暂停代码的执行并返回一个值，它可以与Promise结合使用来处理异步操作</p><p>在实际项目中，我们应该根据实际情况选择适合的异步编程方式，并注意避免回调地狱和错误处理的问题。我们应该尽量使用Promise和async&#x2F;await来处理异步操作，以获得更好的代码可读性和错误处理</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> typescript </tag>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
            <tag> async/await </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
