<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>预编译与变量提升</title>
      <link href="/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/blog//%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译与变量提升"><a href="#预编译与变量提升" class="headerlink" title="预编译与变量提升"></a><center>预编译与变量提升</center></h2><h4 id="1-JavaScript执行三部曲"><a href="#1-JavaScript执行三部曲" class="headerlink" title="1. JavaScript执行三部曲"></a>1. JavaScript执行三部曲</h4><ul><li>语法分析</li><li>预编译</li><li>解析执行</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h4><ul><li>JavaScript预编译发生在代码片段执行前，分为<code>全局预编译（GO: Global Object）</code>、<code>函数预编译（AO: Activation Object）</code>，全局预编译发生在<code>script</code>标签引入执行时（全局作用域），函数预编译发生在函数执行前一刻（函数作用域）。预编译会创建当前环境的执行上下文。</li><li>预编译发生在<code>变量声明</code>和<code>函数声明</code>，<code>匿名函数</code>和<code>函数表达式</code>不进行预编译</li></ul><h4 id="3-Imply-global（暗示全局变量）"><a href="#3-Imply-global（暗示全局变量）" class="headerlink" title="3. Imply global（暗示全局变量）"></a>3. Imply global（暗示全局变量）</h4><p>  任何变量未经声明就赋值，此变量就变为<code>全局对象（window，globalThis）</code>所有</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123; a = <span class="number">2</span> &#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="4-全局预编译"><a href="#4-全局预编译" class="headerlink" title="4. 全局预编译"></a>4. 全局预编译</h4><ul><li>创建<code>GO（Global Object）</code></li><li>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 变量声明）</li></ul><h4 id="5-全局预编译过程"><a href="#5-全局预编译过程" class="headerlink" title="5. 全局预编译过程"></a>5. 全局预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = z = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">y = <span class="title function_">add</span>(x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">z = <span class="title function_">add</span>(x)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>GO</code></p></li><li><p>找变量声明，将变量声明作为<code>GO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Go</span>&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找全局函数声明，将函数名作为<code>GO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GO</span>&#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">y</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">z</span>: <span class="literal">undefined</span></span><br><span class="line">   <span class="attr">add</span>: <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">1</span> &#125; =&gt; <span class="keyword">function</span> <span class="title function_">add</span> (n) &#123; <span class="keyword">return</span> n + <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-函数预编译"><a href="#6-函数预编译" class="headerlink" title="6. 函数预编译"></a>6. 函数预编译</h4><ul><li>创建<code>AO（Activation Object）</code></li><li>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</li><li>将实参值与形参统一</li><li>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code>（优先级：函数声明 &gt; 实参 &gt; 变量声明）</li></ul><h4 id="7-函数预编译过程"><a href="#7-函数预编译过程" class="headerlink" title="7. 函数预编译过程"></a>7. 函数预编译过程</h4><ul><li><p>案例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">d</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="title function_">fn</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>创建<code>AO</code></p></li><li><p>找形参和变量声明，将变量和形参名作为<code>AO</code>对象的属性名，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将实参值与形参统一</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找函数声明，将函数名作为<code>AO</code>对象的属性名，赋值<code>函数体</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AO</span>&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">d</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-变量提升（Hoisting）"><a href="#8-变量提升（Hoisting）" class="headerlink" title="8. 变量提升（Hoisting）"></a>8. 变量提升（<code>Hoisting</code>）</h4><p>  在预编译过程中，<code>变量声明</code>，<code>函数声明</code>会被移到调用前，从而产生<code>变量提升</code></p><ul><li><p><code>函数声明</code>整体提升，无论函数调用和声明的位置是前是后，总会被函数声明移到调用前，函数名与形参或变量名同名时：<code>函数声明</code> &gt; <code>实参</code> &gt; <code>变量声明</code></p></li><li><p><code>匿名函数</code>和<code>函数表达式</code>不会提升</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// undefined: 变量提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()) <span class="comment">// not defined: 函数表达式不会提升</span></span><br></pre></td></tr></table></figure></li><li><p><code>变量声明</code>提升，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，赋值<code>undefined</code>（针对<code>var</code>，<code>let</code>、<code>const</code>存在暂时性死区）</p></li><li><p><code>var</code>：<code>创建</code>和<code>初始化</code>都被提升</p></li><li><p><code>function</code>：整体提升，<code>创建</code>、<code>初始化</code>、<code>赋值</code>都提升</p></li><li><p><code>let</code>、<code>const</code>：<code>创建</code>提升（即变量已存在，但只有等到变量声明语句执行后才能使用）</p></li><li><p>ES6 <code>import</code>具有提升效果，导入模块会提升到整个模块的头部，首先执行（<code>import</code>静态编译，<code>import()</code>，<code>require()</code>动态加载）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-暂时性死区（Temporal-dead-zone，简称TDZ）"><a href="#9-暂时性死区（Temporal-dead-zone，简称TDZ）" class="headerlink" title="9. 暂时性死区（Temporal dead zone，简称TDZ）"></a>9. 暂时性死区（Temporal dead zone，简称TDZ）</h4><p>  <code>暂时性死区</code>本质是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到变量声明语句执行后，才可以获取和使用该变量</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 死区陷阱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> x <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> z <span class="comment">// Reference Error</span></span><br><span class="line"><span class="keyword">let</span> z</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json</title>
      <link href="/blog//package-json/"/>
      <url>/blog//package-json/</url>
      
        <content type="html"><![CDATA[<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><center>package.json</center></h2>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Garbage Collecation</title>
      <link href="/blog//JavaScript-Garbage-Collecation/"/>
      <url>/blog//JavaScript-Garbage-Collecation/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-Garbage-Collecation（垃圾回收）"><a href="#JavaScript-Garbage-Collecation（垃圾回收）" class="headerlink" title="JavaScript Garbage Collecation（垃圾回收）"></a><center>JavaScript Garbage Collecation（垃圾回收）</center></h2><h4 id="1-垃圾回收定义"><a href="#1-垃圾回收定义" class="headerlink" title="1. 垃圾回收定义"></a>1. 垃圾回收定义</h4><p>  找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><h4 id="2-JS垃圾回收机制"><a href="#2-JS垃圾回收机制" class="headerlink" title="2. JS垃圾回收机制"></a>2. JS垃圾回收机制</h4><ul><li><p>标记清除</p><p>  JavaScript中最常用的垃圾回收方式。当变量进入执行环境标记为“进入环境”，离开环境将其标记为“离开环境”，等待清除</p></li><li><p>引用计数</p><p>  语言引擎存在一张“引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数，如果一个值的引用次数是0，就表示这个值不再被使用了，因此可以将这块内存释放</p><p>  引用计数的问题：循环引用</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  obj1.<span class="property">next</span> = obj2</span><br><span class="line">  obj2.<span class="property">next</span> = obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当函数执行结束后，返回值为<code>undefined</code>，所以整个函数以及内部变量都应该被回收，但是根据引用计数方法，<code>obj1</code> 和 <code>obj2</code> 的引用次数都不为0，所以它们不会被回收，解决循环引用的办法：不使用它们的时候手动将它们设为<code>null</code></p></li></ul><h4 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h4><ul><li><p>意外的全局变量</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>; <span class="comment">// 定义成了全局对象(window)属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="number">0</span> <span class="comment">// this指向了全局对象(window)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用严格模式可以避免意外的全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>被遗忘的计时器或回调函数</p></li><li><p>闭包</p></li><li><p>没有清理的DOM元素引用</p></li></ul><h4 id="4-避免内存泄漏的一些方式"><a href="#4-避免内存泄漏的一些方式" class="headerlink" title="4. 避免内存泄漏的一些方式"></a>4. 避免内存泄漏的一些方式</h4><ul><li>减少不必要的全局变量或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li><li>注意程序逻辑，避免“死循环”</li><li>避免创建过多的对象，不使用的时候手动将它们设为null</li></ul><h4 id="5-垃圾回收使用场景优化"><a href="#5-垃圾回收使用场景优化" class="headerlink" title="5. 垃圾回收使用场景优化"></a>5. 垃圾回收使用场景优化</h4><ul><li><p>数组优化</p><p>  将<code>空数组[]</code>赋值给数组对象是清空数组的捷径，但是<code>空数组</code>也会占用内存。实际上<code>array.length = 0</code>也能清空数组，并且同时能实现数组重用，减少内存垃圾产生</p></li><li><p>对象尽量复用</p><p>  对象尽量复用，不用的对象尽可能设置为null，尽快被垃圾回收掉</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index Signature</title>
      <link href="/blog//Index-Signature/"/>
      <url>/blog//Index-Signature/</url>
      
        <content type="html"><![CDATA[<h2 id="Index-Signature"><a href="#Index-Signature" class="headerlink" title="Index Signature"></a><center>Index Signature</center></h2><h4 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h4><p>  你有两个对象，分别描述了两个工作人员的工资：<br>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> salary1 = &#123;</span><br><span class="line">  <span class="attr">baseSalary</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">yearlyBonus</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> salary2 = &#123;</span><br><span class="line">  <span class="attr">contractSalary</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  之后，你想实现一个函数，根据工作人员的工资信息得到总薪资</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">totalSalary</span>(<span class="params">salaryObject: ???</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> salaryObject) &#123;</span><br><span class="line">    total += salaryObject[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">totalSalary</span>(salary1); <span class="comment">// 30</span></span><br><span class="line"><span class="title function_">totalSalary</span>(salary2); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>  看起来函数似乎可以正常工作，<code>salaryObject</code>被<code>typescript</code>推断为any，这时候我们可以传入任何对象。当我们传入的对象值的类型不为<code>number</code>时，此函数将会在运行时报错（比如：<code>&#123; baseSalary: true &#125;</code>）</p><p>  这个时候应该如果定义<code>totalSalary</code>函数的参数<code>totalSalary</code>的类型注解呢？答案是<code>Index Signature</code>（索引签名），接下来我们来看看如何在<code>Typescript</code>中使用索引签名，以及何时需要它</p><h4 id="2-什么是索引签名？"><a href="#2-什么是索引签名？" class="headerlink" title="2. 什么是索引签名？"></a>2. 什么是索引签名？</h4><p>  当你不确定对象属性的名称，只知道属性和值的类型，这时可以使用索引签名来描述。</p><p>  比如<code>salaryObject</code>，我们可以确定属性的类型（<code>string</code>）、值的类型（<code>number</code>），但我们不知道具体的属性名。便可以使用索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> salaryType = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此类型描述了一个以字符串类型作为属性，数字类型作为值的对象。当我们传入非<code>number</code>类型的属性值对象时，<code>typescript</code>将会提示错误</p><h4 id="3-索引签名语法"><a href="#3-索引签名语法" class="headerlink" title="3. 索引签名语法"></a>3. 索引签名语法</h4><p>  索引签名语法非常简单，只需要在方括号内写下属性的类型：<code>&#123; [key: keyType]: valueType &#125;</code>，一些例子：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在第二个例子<code>Iss</code>中，我们还定义了一个<code>name</code>属性，标识此类型对象上必须要有一个<code>name</code>属性，但这里有一个限制，索引签名强制要求所有的属性值必须为索引签名的属性值相匹配（或子类型），否则，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Iss</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  ~~name~~: <span class="built_in">boolean</span> <span class="comment">// Error: Property &#x27;name&#x27; of type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，索引签名属性只允许使用：string、number、symbol、template string（模板字符串）以及只包含这些类型的联合类型</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: ~~<span class="built_in">boolean</span>~~]: <span class="built_in">string</span> <span class="comment">// Error: An index signature parameter type must be &#x27;string&#x27;, &#x27;number&#x27;, &#x27;symbol&#x27;, or a template literal type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-索引签名注意事项"><a href="#4-索引签名注意事项" class="headerlink" title="4. 索引签名注意事项"></a>4. 索引签名注意事项</h4><ul><li><p>访问一个不存在的对象</p><p>当我们视图访问索引签名<code>&#123; [key: string]: string &#125;</code>对象上不存在的对象时，会发生什么？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>正如索引签名定义的那样，<code>Typescript</code>将会把<code>obj.a</code>推断为<code>string</code>，但我们知道，在运行时<code>obj.a</code>实际为<code>undefined</code></p><p>索引签名只会将属性类型映射到值类型，值类型可能会偏离实际允许时的数据，这部分需要根据实际代码自行处理。当然，你也可以将值类型增加<code>undefined</code>类型，这样<code>Typescript</code>会提示你访问的属性可能不存在。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// string | undefined</span></span><br></pre></td></tr></table></figure></li><li><p><code>string</code>和<code>number</code>类型属性</p><p>  当我们定义一个以数字为<code>key</code>的对象，我们可以直接定义为：<code>[key: string]: string</code>，如：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="title class_">Is</span> = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;one&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 obj[&#x27;1&#x27;] 或 obj[1] 访问</span></span><br><span class="line"><span class="keyword">const</span> val1 = obj[<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> val2 = obj[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>  为什么我们定义时<code>key</code>的类型为<code>string</code>，但确可以通过<code>number</code>访问，<code>Typescript</code>也不会提示错误呢？</p><p>  因为<code>JavaScript</code>在访问对象时，会隐式的将数字强制转换为字符串（<code>obj[1]</code>→ <code>obj[&#39;1&#39;]</code>），这意味着访问<code>obj[1]</code>和<code>obj[&#39;1&#39;]</code>是一样的，<code>Typescript</code>也执行这种隐式转换。因此我们可以同时定义两种类型的索引签名：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同样也要注意，数字类型属性值必须与字符串类型属性值的相匹配（或子类型）</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: ~~<span class="built_in">boolean</span>~~ <span class="comment">// Error: &#x27;number&#x27; index type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string | number&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-索引签名与Record"><a href="#5-索引签名与Record" class="headerlink" title="5. 索引签名与Record"></a>5. 索引签名与Record</h4><p>  <code>Typescript</code>提供了一个实用类型<code>Record</code>：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> &#125; = &#123; <span class="attr">prop</span>: <span class="string">&#x27;Value&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>  它与索引签名类似，那么我们如何区分何时使用索引签名，何时使用<code>Record</code>呢？</p><p>  正如我们前面所提到的，索引签名对属性类型定义存在限制（索引签名属性类型只允许：string、number、symbol、template string）。当我们尝试在索引签名字面量类型或字面量联合类型，<code>Typescript</code>将会提示错误：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = &#123;</span><br><span class="line">  [~~key~~: <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.</span></span><br></pre></td></tr></table></figure><p>  但我们可以通过<code>Record</code>定义：</p>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Is</span> = <span class="title class_">Record</span>&lt;<span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;hobby&#x27;</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">Is</span> =  &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lemon&#x27;</span>,</span><br><span class="line">  <span class="attr">hobby</span>: <span class="string">&#x27;program&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以，建议使用索引签名来注释通用对象（当我们只知道属性的类型和属性值的类型时）。但当我们知道具体的属性时，建议使用<code>Record&lt;keys, Type&gt;</code>来注释特定对象</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li>索引签名的语法：<code>[key: KeyType]: ValueType</code>，其中<code>KeyType</code>类型只允许：<code>string、number、symbol、template string</code>，而<code>ValueType</code>可以是任何类型</li><li>当你不知道要注释的对象的具体结构（具体的属性名），但你知道属性名的类型和属性值的类型，那你可能需要的就是索引签名</li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new.target</title>
      <link href="/blog//new-target/"/>
      <url>/blog//new-target/</url>
      
        <content type="html"><![CDATA[<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a><center>new.target</center></h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><blockquote><p><code>new.target</code>属性（ES6引入）允许你检测函数或构造方法是否通过<code>new</code>运算符进行调用。通过new运算符被初始化的函数或构造方法时，<code>new.target</code>返回一个指向构造方法或函数的引用，在普通的函数调用中，<code>new.target</code>返回<code>undefined</code></p></blockquote><p>  注意：</p><ul><li>在<code>arrow function</code>中，没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，<code>new.target</code>指向最近的外层函数的<code>new.target</code></li><li>在子类继承父类时，<code>new.target</code>指向初始化类的类定义，即子类</li></ul><h4 id="2-在ES5中如何限制函数通过new运算符调用"><a href="#2-在ES5中如何限制函数通过new运算符调用" class="headerlink" title="2. 在ES5中如何限制函数通过new运算符调用"></a>2. 在ES5中如何限制函数通过<code>new</code>运算符调用</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>this</code>将指向构造函数实例</p></li><li><p>普通调用函数，非严格模式<code>this</code>指向<code>window</code>，严格模式指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Window &#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以通过判断<code>this</code>是否当前构造函数的实例，来判断是否通过<code>new</code>运算符调用，使用<code>this instanceof [构造函数]</code>，通过<code>new</code>调用返回<code>true</code>，普通调用返回<code>false</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 不建议使用 arguments.callee.name，在严格模式下arguments属性被移除</span></span><br><span class="line">  <span class="keyword">if</span>(!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Instance</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>()  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>但通过此方法判断并不完全准确，如果调用时通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向，将<code>this</code>指向构造函数实例，以上方法将无效</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()))  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-new-target"><a href="#3-new-target" class="headerlink" title="3. new.target"></a>3. new.target</h4><ul><li><p>通过<code>new</code>运算符调用构造函数，<code>new.target</code>指向构造方法或函数的引用</p></li><li><p>普通调用函数，<code>new.target</code>指向<code>undefined</code></p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span>.<span class="property">target</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>因此我们可以使用<code>new.target</code>来限制构造函数必须通过<code>new</code>运算符调用</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Instance</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Failed to construct &#x27;Instance&#x27;: Please use the &#x27;new&#x27; operator, this DOM object constructor cannot be called as a function.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>())  <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变this指向</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Instance</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>())) <span class="comment">// Uncaught TypeError: ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Instance</span>()) <span class="comment">// Instance() &#123; return new.target &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-使用new-target模拟实现抽象类"><a href="#4-使用new-target模拟实现抽象类" class="headerlink" title="4. 使用new.target模拟实现抽象类"></a>4. 使用<code>new.target</code>模拟实现抽象类</h4><ul><li><p>因为当子类继承父类时，<code>new.target</code>指向初始化类的类定义</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>) &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123; <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">P</span>() <span class="comment">// class P &#123; constructor() &#123; console.log(new.target) &#125; &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">S</span>() <span class="comment">// class S extends P &#123; constructor() &#123; super() &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>利用这一特性，可以模拟实现抽象类</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === P) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&#x27;Cannot create an instance of an abstract class.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_ inherited__">P</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">P</span>()) <span class="comment">// Uncaught SyntaxError: Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">S</span>()) <span class="comment">// S &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ul><li>在ES5中，通过<code>new</code>运算符调用时<code>this</code>指向构造函数实例，普通调用时<code>this</code>在非严格模式指向<code>window</code>，严格模式指向<code>undefined</code>，利用这一特性，结合<code>this instanceof [构造函数]</code>，可以判断是否通过<code>new</code>运算符调用构造函数，但此方法并不安全，可以通过<code>apply</code>&#x2F;<code>call</code>&#x2F;<code>bind</code>改变<code>this</code>指向</li><li>在ES6中，引入<code>new.target</code>属性，通过<code>new</code>运算符调用时<code>new.target</code>指向构造方法或函数的引用，普通调用函数，<code>new.target</code>指向<code>undefined</code>，可以通过此属性判断是否通过<code>new</code>运算符调用构造函数</li><li>利用<code>new.target</code>属性，可以模拟实现抽象类</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Preflight request</title>
      <link href="/blog//Preflight-request/"/>
      <url>/blog//Preflight-request/</url>
      
        <content type="html"><![CDATA[<h2 id="Preflight-request（预检请求）"><a href="#Preflight-request（预检请求）" class="headerlink" title="Preflight request（预检请求）"></a><center>Preflight request（预检请求）</center></h2><h4 id="1-什么是预检请求？"><a href="#1-什么是预检请求？" class="headerlink" title="1. 什么是预检请求？"></a>1. 什么是预检请求？</h4><blockquote><p>一个<code>CORS</code>预检请求是用于检查服务器是否支持<code>CORS</code>（跨域资源共享），由浏览器自动通过<code>OPTIONS</code>方法发起（<strong>非简单请求</strong>才会发起预检请求）。当预检请求完成，服务器确认允许后，才发起实际的HTTP请求。</p></blockquote><h4 id="2-简单请求与非简单请求"><a href="#2-简单请求与非简单请求" class="headerlink" title="2. 简单请求与非简单请求"></a>2. 简单请求与非简单请求</h4><ul><li><p>简单请求</p><ul><li>请求方法：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>请求首部字段只包含：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type<ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul></li></ul></li><li>如果请求是使用XMLHttpRequest对象发出的，在返回的XMLHttpRequest.upload对象属性上没有注册任何事件监听器；也就是说，给定一个XMLHttpRequest实例xhr，没有调用xhr.upload.addEventListener()，以监听该上传请求</li><li>请求中没有使用ReadableStream对象</li></ul></li><li><p>非简单请求</p><ul><li>不满足简单请求的都是非简单请求</li></ul></li></ul><h4 id="3-预检请求中的请求首部字段"><a href="#3-预检请求中的请求首部字段" class="headerlink" title="3. 预检请求中的请求首部字段"></a>3. 预检请求中的请求首部字段</h4><ul><li>Origin：请求源URL（不包含路径）</li><li>Access-Control-Request-Method：实际请求所使用的HTTP方法</li><li>Access-Control-Request-Headers：实际请求时携带的自定义首部字段</li></ul><img src="/blog/Preflight-request/request-header.png" class="" title="Preflight request header"><h4 id="4-预见请求中的响应首部字段"><a href="#4-预见请求中的响应首部字段" class="headerlink" title="4. 预见请求中的响应首部字段"></a>4. 预见请求中的响应首部字段</h4><ul><li>Access-Control-Allow-Origin：允许该源访问资源地址，可以使用<code>*</code>通配符，表示任意源（仅当不需要携带<code>Cookie</code>时，如果携带<code>Cookie</code>，必须指定具体的源地址，否则将会请求失败）</li><li>Access-Control-Allow-Methods：允许使用的HTTP方法</li><li>Access-Control-Allow-Headers：允许使用的请求首部字段</li><li>Access-Control-Allow-Credentials：是否允许携带Cookie</li><li>Access-Control-Expose-Headers：<code>XMLHttpRequest</code>对象的 <code>getResponseHeader()</code>方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头</li><li>Access-Control-Max-Age：指定预检请求缓存时间，单位为秒，默认5秒</li></ul><img src="/blog/Preflight-request/response-header.png" class="" title="Preflight response header"><h4 id="5-完整请求流程图"><a href="#5-完整请求流程图" class="headerlink" title="5. 完整请求流程图"></a>5. 完整请求流程图</h4><img src="/blog/Preflight-request/request-flow.png" class="" title="request flow">]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
